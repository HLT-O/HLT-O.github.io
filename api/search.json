[{"id":"c60727c6131ffb650a7eb77cb79c7e0e","title":"Vue面试-虚拟DOM","content":"虚拟 DOM虚拟DOM概念随着react的诞生而诞生，由facebook提出，其卓越的性能很快得到广大开发者的认可；继react之后vue2.0也在其核心引入了虚拟DOM的概念\n什么是虚拟DOM(VDOM)？vdom可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。dom 树对应的虚拟 dom 对象（ js 对象），如下：可见上面的DOM结构，不论是标签名称还是标签的属性或标签的子集，都会对应在下面的树结构里。\n为什么要使用虚拟DOM？虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在react，vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改 就变成了 js 对象的属性的更改 ，这样一来就能查找 js 对象的属性变化要比查询 dom 树的 性能开销小。\n其实并不是查询 dom 树性能开销大而是 dom 树的实现模块和 js 模块是分开的这些跨模块的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。\n他们的思想是每次更新 dom 都尽量避免刷新整个页面，而是有针对性的 去刷新那被更改的一部分 ，来释放掉被无效渲染占用的 gpu，cup 性能。\n\nangular 采用的机制是 脏值检测查机制 所有使用了 ng 指令的 scope data 和 插值语法 语法的 scope data 都会被加入脏检测的队列\n\nvue 采用的是虚拟dom通过重写 setter ， getter实现观察者监听 data 属性的变化生成新的虚拟 dom 通过 h 函数创建真实 dom 替换掉dom树上对应的旧 dom。\n\nreact 也是通过虚拟 dom 和 setState 更改 data 生成新的虚拟 dom 以及 diff 算法来计算和生成需要替换的 dom 做到局部更新的。\n\n\n虚拟dom的原理diff算法 深度优先遍历diff的过程就是调用patch函数，就像打补丁一样修改真实dom\nvirtual dom有哪些好处虚拟 DOM 不会立马进行排版与重绘操作虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部虚拟DOM主要做了什么虚拟DOM本身是什么（JS对象）为什么虚拟 DOM 的操作比 DOM 更快；总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作\n你的知道浏览器的虚拟DOM与真实DOM的区别（注意：需不需要虚拟DOM，其实与框架的DOM操作机制有关）：虚拟DOM不会进行排版与重绘操作虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗真实DOM频繁排版与重绘的效率是相当低的虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）使用虚拟DOM的损耗计算：总损耗&#x3D;虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘直接使用真实DOM的损耗计算：总损耗&#x3D;真实DOM完全增删改+（可能较多的节点）排版与重绘总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作\n","slug":"Vue面试-虚拟DOM","date":"2022-07-28T13:57:49.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"8b4c372403610b1ffccec2e1fcd54ba5","title":"JS的一些小知识点","content":"var 、let 、const 的区别\n\n\n\nvar\nlet\nconst\n\n\n\n作用域\n函数作用域\n块级作用域\n块级作用域\n\n\n变量提升\n会变量提升，且会初始化赋值为undefined\n会变量提升,但不会初始化(存在暂时性死区)\n会变量提升,但不会初始化(存在暂时性死区)\n\n\n能否修改\n能修改\n能修改\n不能,但可以修改引用中的内容\n\n\nfunction sayHi() &#123;\n  console.log(name)//undefined\n  console.log(age)//ReferenceError\n  var name = 'Lydia'\n  let age = 21\n&#125;\nsayHi()\nJS 对象中 . 与 [] 的区别在javaScript中，访问对象的属性有 .property 和 [property] 两种方法\n\n相同点: 都是用来获取obj的属性值\n不同点: 静态与动态使用\n\n[ ] 运算符可以使用字符串变量的内容作为属性名，. 运算符则不能\nlet obj = &#123;\n            name1:'winnie',\n            name2:'a莹',\n            name3:'圆'\n        &#125;\n        let name = 'name3'\nconsole.log(obj.name); //当.属性 为变量时 结果为 undefined\nconsole.log(obj[name]);  //[] 变量亦能使用  结果为 圆\n[ ] 运算符可以使用纯数字作为属性名，. 运算符则不能\nlet obj = &#123;\n            name1:'winnie',\n            2:'a莹',\n            3:'圆'\n        &#125;\nconsole.log(obj[2]); // a莹\nconsole.log(obj.2);  //报错Uncaught SyntaxError: missing ) after argument list   【少了括号？？】\n事件传播的三个阶段Capturing &gt; Target &gt; Bubbling在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。\n\njs隐式转换普通类型转换字符串拼接 &gt; 数字运算\n\n出现字符串拼接的情况，其他类型都要转换为字符串\n没有字符串拼接，有运算符，则全部转为数字\n\nconsole.log('1' - 2 + false);// 12false\nconsole.log(2+true);// 3\nconsole.log(-true);// -1\n\n复杂类型转换复杂数据类型在隐式转换时会先 valueOf() 取原始值，再转成 String ，然后再转成 Number 。如果转成字符串后能拼接，则不转Number，直接拼接。\nconsole.log([]+1);// '1'\nconsole.log(&#123;&#125;+1);// '[object Object]1'\nconsole.log([]-1);//-1\nconsole.log(&#123;&#125;-1);// NaN\n\n关系运算符关系运算符会把其他数据类型转换成number之后再比较关系\nconsole.log(Number('2'))//2\nconsole.log(Number('a'))//NaN\nconsole.log(Number(&#123;&#125;));//NaN\nconsole.log(Number([]));//0\nconsole.log(Number(undefined));//NaN\nconsole.log(Number(null));//0\n//例如:\nconsole.log('2'>10);//false\nconsole.log([]>-1);//true\n\nconsole.log(Boolean([]));//true\nconsole.log(Number([]));//0\nconsole.log([]==false);//true\nconsole.log(![]==false);//true 先进行布尔运算\nconsole.log(![]==0)//true\nconsole.log([]==0)//true\nconsole.log([]==[]);//false\n\n有关于字符串的比较\n\n单个字符串比较unicode编码 (始终遵循A&lt;Z&lt;a&lt;z)\n多个字符串比较从左往右依次单个比较（这里注意不会比完有一个不一样就比出结果了）\n\nconsole.log('a' > 'b');//false\nconsole.log('a' > 'A');//true\nconsole.log('abc' > 'b');//false\nconsole.log('abc' > 'aad');//tru\n\n\n\n\n\n\n特殊\nconsole.log(null == undefined);//true\n据说是因为设计者觉得它俩很像，所以才让它们相等\n\n一个有趣的题目\n//经典面试题\nvar a = ? ? ? ;\n \nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log('yes')\n&#125;\n//给a设置内容  让他实现值同时等于1 2 3\n//答案\nvar a = &#123;\n    i:0,//声明一个属性i\n    //每次对比都会先调用 valueOf() 这个方法，所以我们自己给他定义一个valueOf()\n    valueOf:function()&#123;\n        return ++this.i;//每调用一次，让对象的a属性的i值自增并返回\n    &#125;\n&#125; ;","slug":"JS的一些小知识点","date":"2022-05-20T08:20:55.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"03aba69ba9901887c6cdf14c73c6fada","title":"js类基础","content":"声明类的语法//函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //定义方法,在原型上面定义\n    Stu.prototype.getName = function () &#123;\n      console.log(this.name);\n    &#125;;\n    stu = new Stu(\"HHHH\", 19);\n    stu.getName();\n// 语法糖\n    class User &#123;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n      //定义方法\n      show() &#123;&#125; //不用加逗号\n      getName() &#123;\n        console.log(this.name);\n      &#125;\n    &#125;\n    let user = new User(\"HLT\", 21);\n    user.getName();\n\n\n\n\n\n\n注意\n用class创建的类中的方法是不能遍历的\n//打印 User 中的 getName 的描述\nconsole.log(\n      JSON.stringify(\n        Object.getOwnPropertyDescriptor(User.prototype, \"getName\"),\n        null,\n        2\n      )\n    );\n    //结果\n    /*&#123;\n      \"writable\": true,\n      \"enumerable\": false,//不可枚举\n      \"configurable\": true\n    &#125;*/\n    //遍历 User 的实例\n    for (const key in user) &#123;\n      console.log(key); //name age\n    &#125;\n但用构造函数创建的类中的方法可以遍历\n//打印 Stu 中的 getName 的描述\nconsole.log(\n      JSON.stringify(\n        Object.getOwnPropertyDescriptor(Stu.prototype, \"getName\"),\n        null,\n        2\n      )\n    );\n    //结果\n    /*&#123;\n      \"writable\": true,\n      \"enumerable\": true,//可枚举\n      \"configurable\": true\n    &#125;*/\n    //遍历 Stu 的实例\n    for (const key in stu) &#123;\n      console.log(key);//name age getName\n    &#125;\n\n\n类的静态属性静态属性：实例对象无法访问，只能通过构造函数名来访问\n //函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //静态属性 直接在构造函数上添加\n    Stu.age = 12;\n    let s = new Stu(\"HLT\", 22);\n    console.log(s.age);\n    console.log(Stu.age);\n//语法糖写法\n    class User &#123;\n      //静态属性 要加 static 关键字\n      static age = 33;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n    &#125;\n    let u = new User(\"HHHH\", 22);\n    console.log(u.age);\n    console.log(User.age);\n静态方法静态方法：实例对象无法访问，只能通过构造函数名来访问\n //函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //静态方法 直接在构造函数上添加, this 指向构造函数\n    //这是一个创建实例的方法\n    Stu.create = function (...args) &#123;\n      return new this(...args);\n    &#125;;\n    let s = Stu.create(\"HLT\", 22);\n    console.log(s);\n//语法糖写法\n    class User &#123;\n      //静态方法 要加 static 关键字 this指向此类\n      //这是一个创建实例的方法\n      static create(...args) &#123;\n        return new this(...args);\n      &#125;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n    &#125;\n    let u = User.create(\"HHHH\", 22);\n    console.log(u);\n静态方法的练习const data = [\n  &#123; name: \"mysql\", price: 212 &#125;,\n  &#123; name: \"js\", price: 502 &#125;,\n  &#123; name: \"vue\", price: 21 &#125;,\n];\nclass Lesson &#123;\n  constructor(data) &#123;\n    this.model = data;\n  &#125;\n  //将每个数据创建为实例对象\n  static create(data) &#123;\n    return data.map((item) => new this(item));\n  &#125;\n  //获取最高的价格\n  static maxPrice(data) &#123;\n    return data.sort((a, b) => b.price() - a.price())[0];\n  &#125;\n  //获取价格\n  price() &#123;\n    return this.model.price;\n  &#125;\n  //获取名字\n  name() &#123;\n    return this.model.name;\n  &#125;\n&#125;\nlet lesson = Lesson.create(data);\nconsole.log(lesson); //为什么输出的结果是排序后的\nconsole.log(Lesson.maxPrice(lesson).name());","slug":"js类基础","date":"2022-05-19T02:16:01.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"79e2e1ab4b9bedc5846bde4a579442cd","title":"Vue面试","content":"生命周期生命周期图: \nkeep-liveprops\ninclude - string | RegExp | Array。只有名称匹配的组件会被缓存。\nexclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存。\nmax - number | string。最多可以缓存多少组件实例。\n\n用法&lt; keep-alive &gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt; transition &gt; 相似， &lt; keep-alive &gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n当组件在 &lt; keep-alive &gt; 内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用，取而代之的是 activated 和 deactivated。(这会运用在 &lt; keep-alive &gt; 的直接子节点及其所有子孙节点。)\n主要用于保留组件状态或避免重新渲染。\n&lt;!-- 基本 -->\n&lt;keep-alive>\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- 多个条件判断的子组件 -->\n&lt;keep-alive>\n  &lt;comp-a v-if=\"a > 1\">&lt;/comp-a>\n  &lt;comp-b v-else>&lt;/comp-b>\n&lt;/keep-alive>\n\n&lt;!-- 和 `&lt;transition>` 一起使用 -->\n&lt;transition>\n  &lt;keep-alive>\n    &lt;component :is=\"view\">&lt;/component>\n  &lt;/keep-alive>\n&lt;/transition>\n\n注意， &lt; keep-alive &gt; 是用在其一个直属的子组件被切换的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素， 要求同时只有一个子元素被渲染。\ninclude 和 excludeinclude 和 exclude prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：\n&lt;!-- 逗号分隔字符串 -->\n&lt;keep-alive include=\"a,b\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- regex (使用 `v-bind`) -->\n&lt;keep-alive :include=\"/a|b/\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- Array (使用 `v-bind`) -->\n&lt;keep-alive :include=\"['a', 'b']\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。\nmax最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n&lt;keep-alive :max=\"10\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n\n\n\n\n\n警告\n&lt; keep-alive &gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。\n\nv-if   VS   v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\nv-if 与 v-show 的优先级问题\n2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。\n3.x 版本中 v-if 总是优先于 v-for 生效\n\n\n\n\n\n\n\n注意\n不推荐同时使用 v-if 和 v-for\n\nrefref 被用来给元素或子组件注册引用信息。引用信息将会被注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是那个 DOM 元素；如果用在子组件上，引用就指向组件实例：\n&lt;p ref=\"p\">hello&lt;/p>\n\n&lt;!-- vm.$refs.child 会是子组件实例 -->\n&lt;child-component ref=\"child\">&lt;/child-component>\n\n&lt;!-- 当动态绑定时，我们可以将 ref 定义为回调函数，显式地传递元素或组件实例 -->\n&lt;child-component :ref=\"(el) => child = el\">&lt;/child-component>\n关于 ref 注册时机的重要说明：因为 ref 本身是作为渲染函数的结果而创建的，在初始渲染时你不能访问它们——它们还不存在！$refs 也是非响应式的，因此你不应该试图用它在模板中做数据绑定。\nnextTick将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它。\nimport &#123; createApp, nextTick &#125; from 'vue'\n//例一\nconst app = createApp(&#123;\n  setup() &#123;\n    const message = ref('Hello!')\n    const changeMessage = async newMessage => &#123;\n      message.value = newMessage\n      await nextTick()\n      console.log('Now DOM is updated',message)\n    &#125;\n  &#125;\n&#125;)\n//例二\nconst app = createApp(&#123;\n\t  setup() &#123;\n\t    const message = ref('Hello!')\n\t    const changeMessage = async newMessage => &#123;\n\t\t\tnextTick(()=>&#123;\n\t\t\t\tconsole.log('Now DOM is updated',message)\n\t\t\t&#125;)\n\t    &#125;\n\t  &#125;\n\t&#125;)\nscoped什么是scoped在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。\nscoped的实现原理Vue中的scoped属性的效果主要是通过PostCss实现的。以下是转译前的代码:\n&lt;style scoped>\n    .example&#123;\n        color:red;\n    &#125;\n&lt;/style>\n&lt;template>\n    &lt;div>scoped测试案例&lt;/div>\n&lt;/template>\n转译后:\n.example[data-v-5558831a] &#123;\n  color: red;\n&#125;\n&lt;template>\n    &lt;div class=\"example\" data-v-5558831a>scoped测试案例&lt;/div>\n&lt;/template>\nPostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\nscoped的渲染规则\n给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素\n在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式\n\nsass 和 less 的样式穿透在Vue项目中，当我们引入第三方组件库时(如使用element-ui)，需要在局部组件中修改第三方组件库样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped\n这俩个常用的样式穿透的方式 有俩种 分别是 &#x2F;deep&#x2F; 与 ::v-deep\n外层容器 /deep/ 组件 &#123; &#125;\n\n外层容器 ::v-deep 组件 &#123; &#125;\nVue 是怎么实现响应式的//更新视图\nconst updateView = ()=>&#123;\n    console.log(\"视图更新\");\n&#125;\n\n//监视数组变化\n/**\n *  因为 Object.defineProperty 无法监视数组的变化\n *  所以重新定义数组原型\n */\nconst oldArrayProperty = Array.prototype\n\n//创建对象，原型指向 oldArrayProperty ，再扩展的新方法不会污染原型\nconst arrProto = Object.create(oldArrayProperty);\n['push','shift','unshift','pop','splice'].forEach(methodName => &#123;\n    //这个方法主要用来更新视图\n    arrProto[methodName] = function()&#123;\n        console.log(`监听到数组调用了$&#123;methodName&#125;方法`);\n        updateView()\n        //调用原来原型对象上的相应方法\n        oldArrayProperty[methodName].call(this,...arguments)\n    &#125;\n&#125;);\n\n//监听\nconst defineReactive = (data,key,value)=>&#123;\n   observe(value)   //再次判断data中每个属性是否为需要深度监视，（递归）\n   Object.defineProperty(data,key,&#123;        \n        get()&#123;\n            return value\n        &#125;,\n        set(nweValue)&#123;\n            if(nweValue !== value)&#123;\n                observe(nweValue)   //在赋值的时候判断值是否需要深度监视\n                console.log('修改  '+ key+' : '+value+'  >>>',nweValue);\n                value = nweValue\n                updateView()\n            &#125;\n        &#125;\n   &#125;)\n&#125;\n\nconst observe = (data)=>&#123;\n    if(typeof data !== 'object' || data === null)&#123;\n        return data\n    &#125;\n    if(Array.isArray(data))&#123;\n       data.__proto__ =  arrProto\n    &#125;\n     for(key in data)&#123;\n         defineReactive(data,key,data[key])\n     &#125;\n&#125;\n\nconst data = &#123;\n    aa:11,\n    bb:'123',\n    cc:&#123;\n        dd:222\n    &#125;,\n    gg:[2,2,2]\n&#125;\n\nobserve(data)\n\ndata.aa = 22\ndata.bb = 'sss'\ndata.cc.dd = 111\ndata.bb = &#123;\n    ee:'111'\n&#125;\ndata.bb.ee = 222\ndata.gg.push(222)\n","slug":"Vue面试","date":"2022-05-18T11:02:15.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"01dafa857bbdf984f605b3b52dec3c19","title":"generator基础","content":"Generator 基础入门所谓 Generator 函数它是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即拥有暂停函数执行的效果）。\nfunction* gen() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next(); // &#123; value: 2, done: false &#125;\ng.next(); // &#123; value: 3, done: false &#125;\ng.next(); // &#123; value: undefined, done: true &#125;\ng.next(); // &#123; value: undefined, done: true &#125;\n上述的函数就是一个 Generator 生成器函数的例子，我们通过在函数声明后添加一个 * 的语法创建一个名为 gen 的生成器函数。\n调用创建的生成器函数会返回一个 Generator { } 生成器实例对象。\n\n所谓返回的 g 生成器对象你可以简单的将它理解成为类似这样的一个对象结构:\n&#123;\n    next: function () &#123;\n        return &#123;\n            done:Boolean, // done表示生成器函数是否执行完毕 它是一个布尔值\n            value: VALUE, // value表示生成器函数本次调用返回的值\n        &#125;\n    &#125;\n&#125;\n\n首先，我们通过 let g &#x3D; gen() 调用生成器函数创建了一个生成器对象 g ，此时 g 拥有 next 上述结构的 next 方法。\n  这一步，我们成为 g 为返回的生成器对象， gen 为生成器函数。通过调用生成器函数 gen 返回了生成器对象 g 。\n\n之后，生成器对象中的 next 方法每次调用会返回一次 { value:VALUE, done:boolean }的对象。\n  每次调用生成器对象的 next 方法会返回一个上述类型的 object:\n\n\n其中 done 表示生成器函数是否执行完毕,而 value 表示生成器函数中本次 yield 对应的值。\n我们来详细拆开上述函数的执行过程来看看：\n\n首先调用 gen() 生成器函数返回 g 生成器对象。\n其次返回的 g 生成器对象中拥有一个 next 的方法。\n每当我们调用 g.next() 方法时，生成器函数紧跟着上一次进行执行，直到函数碰到 yield 关键值。\nyield 关键字会停止函数执行并将 yield 后的值返回作为本次调用 next 函数的 value 进行返回。\n同时，如果本次调用 g.next() 导致生成器函数执行完毕，那么此时 done 会变成 true 表示该函数执行完毕，反之则为 false 。\n\n\n\n比如当我们调用 let g &#x3D; gen() 时，会返回一个生成器函数，它拥有一个 next方法。\n之后当第一次调用 g.next() 方法时，会执行生成器函数 gen 。函数会进行执行，直到碰到 yield 关键字会进行暂停，此时函数会暂停到 yield 1 语句执行完毕，将 1 赋给 value\n同时因为生成器函数 gen 并没有执行完毕，所以此时 done 应该为 false 。所以此时首次调用 g.next() 函数返回的应该是 { value: 1, done: false }。\n之后，我们第二次调用 g.next() 方法时，函数会从上一次的中断结果后进行执行。也就是会继续 yield 2 语句。\n当遇到 yield 2 时，又因为碰到了 yield 语句。此时函数又会被中断，因为此时函数并没有执行完成，并且yield 语句后紧挨着的是 2 所以第二个 g.next() 会返回 { value: 2 , done: false }。\n同样，yield 3; 回和前两次执行逻辑相同。\n需要额外注意的是，当我们第四次调用迭代器 g.next() 时，因为第三次 g.next() 结束时生成器函数已经执行完毕了。所以再次调用 g.next() 时，由于函数结束 done 会变为 false 。同时因为函数不存在返回值，所以 value 为 undefined。\n上边是一个基于 Generator 函数的简单执行过程，其实它的本质非常简单：\n调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 { value: Value, done: boolean }的对象。\nGenerator 函数返回值我们先来看这样一段代码：\nfunction* gen() &#123;\n  const a = yield 1;\n  console.log(a,'this is a')\n  const b = yield 2;\n  console.log(b,'this is b')\n  const c = yield 3;\n  console.log(c,'this is c')\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next('param-a'); // &#123; value: 2, done: false &#125;\ng.next('param-b'); // &#123; value: 3, done: false &#125;\ng.next('param-c'); // &#123; value: undefined, done: true &#125;\n\n// 控制台会打印:\n// param-a this is a\n// param-b this is b\n// param-c this is c\n这里，我们着重来看看调用生成器对象的 next 方法传入参数时究竟会发生什么事情，理解 next() 方法的参数是后续 Generator 解决异步的重点实现思路。\n上文我们提到过，生成器函数中的 yield 关键字会暂停函数的运行，简单来说比如我们第一次调用 g.next() 方法时函数会执行到 yield 1 语句，此时函数会被暂停。\n当第二次调用 g.next() 方法时，生成器函数会继续从上一次暂停的语句开始执行。这里有一个需要注意的点：当生成器函数恢复执行时，因为上一次执行到 const a &#x3D; yield 1 语句的右半段并没有给 const a进行赋值。\n那么此时的赋值语句 const a &#x3D; yield 1，a 会被赋为什么值呢？ 细心的同学可能已经发现了。我们在 g.next(‘param-a’) 传入的参数 param-a 会作为生成器函数重新执行时，上一次 yield 语句的返回值进行执行。\n简单来说，也就是调用 g.next(‘param-a’)恢复函数执行时，相当于将生成器函数中的 const a &#x3D; yield 1; 变成 const a &#x3D; ‘param-a’; 进行执行。\n这样，第二次调用 g.next(‘param-a’)时自然就打印出了 param-a this is a 。\n同样当我们第三次调用 g.next(‘param-b’) 时，本次调用 next 函数传入的参数会被当作 yield 2 运算结果赋值给 b 变量，执行到打印时会输出 param-b this is b。\n同理 g.next(‘paramc’) 会输出 param-c this is b。\n总而言之，当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。\n自然，第一次调用 g.next() 传入参数是毫无意义的。因为首次调用 next 函数时，生成器函数并没有任何执行自然也没有 yield 关键字处理。\n接下来我们来看看所谓的生成器函数返回值:\nfunction* gen() &#123;\n  const a = yield 1;\n  console.log(a, 'this is a');\n  const b = yield 2;\n  console.log(b, 'this is b');\n  const c = yield 3;\n  console.log(c, 'this is c');\n  return 'resultValue'\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next('param-a'); // &#123; value: 2, done: false &#125;\ng.next('param-b') // &#123; value: 3, done: false &#125;\ng.next() // &#123; value: 'resultValue', done: true &#125;\ng.next() // &#123; value: undefined, done: true &#125;\n当生成器函数存在 return 返回值时，我们会在第四次调用 g.next() 函数恢复执行，此时生成器函数继续执行函数执行完毕。\n此时自然 done 会变为 true 表示生成器函数已经执行完毕，之后，由于函数存在返回值所以随之本次的 value 会变为 ‘resultValue’ 。\n也就是当生成器函数执行完毕时，原本本次调用 next 方法返回的 {done:true,value:undefined} 变为了{ done:true,value:’resultValue’}。\n","slug":"generator基础","date":"2022-05-17T02:44:43.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"98c0136b7cbfc99c12e56d7a4696a8e1","title":"async、await的用法","content":"async await 的用法描述async函数可能包含0个或者多个await表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用async &#x2F; await关键字就可以在异步代码中使用普通的try &#x2F; catch代码块。async函数一定会返回一个promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。\n\n\n\n\n\n\n备注\nawait关键字只在async函数内有效。如果你在async函数体之外使用它，就会抛出语法错误 SyntaxError 。\n\n\n\n\n\n\n\n备注\nasync&#x2F;await的目的为了简化使用基于promise的API时所需的语法。async&#x2F;await的行为就好像搭配使用了生成器和promise。\n\n返回值一个Promise，这个promise要么会通过一个由async函数返回的值被解决，要么会通过一个从async函数中抛出的（或其中没有被捕获到的）异常被拒绝。\n例子//成功的promise\n    function testResolve(val) &#123;\n      return new Promise((resolve) => &#123;\n        setTimeout(() => &#123;\n          resolve(val);\n        &#125;, 1000);\n      &#125;);\n    &#125;\n    //失败的promise\n    function testReject(val) &#123;\n      return new Promise((resolve, reject) => &#123;\n        setTimeout(() => &#123;\n          reject(val);\n        &#125;, 1000);\n      &#125;);\n    &#125;\n    // 加了async 的方法会返回一个promise（默认undefined)\n    async function get() &#123;\n      //使用 try/catch 抛出错误\n      try &#123;\n        //await后的代码会等待promise完成后才执行\n        let res1 = await testResolve(111);\n        console.log(res1);//111\n        let res2 = await testReject(222);\n        console.log(res2);\n        let res3 = await testResolve(333);\n        console.log(res3);\n      &#125; catch &#123;\n        return \"失败\";\n      &#125;\n      return \"成功\";\n    &#125;\n    get()\n      .then((res) => console.log(res))\n      .catch((res) => console.log(res));//失败\n提示async function foo() &#123;\n   return 1\n&#125;\n// 等价于:\nfunction foo() &#123;\n   return Promise.resolve(1)\n&#125;\nasync函数的函数体可以被看作是由0个或者多个await表达式分割开来的。从第一行代码直到（并包括）第一个await表达式（如果有的话）都是同步运行的。这样的话，一个不含await表达式的async函数是会同步运行的。然而，如果函数体内有一个await表达式，async函数就一定会异步执行。\n例如：\nasync function foo() &#123;\n   await 1\n&#125;\n// 等价于:\nfunction foo() &#123;\n   return Promise.resolve(1).then(() => undefined)\n&#125;","slug":"async、await的用法","date":"2022-05-11T13:34:32.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"8cb2b3268d741ec8cb2f77e2fe593594","title":"手写代码","content":"面试出场率及高的手写代码节流let dom1 = document.querySelector(\"#dom1\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\n//第一个参数为 点击事件的操作函数 第二个参数为 延迟操作的时间\nfunction throttle(fn, delay) &#123;\n//定义一个定时器变量  用于判断点击时是否有定时器\nlet timer = null;\n//返回一个函数，每次点击 就会调用这个函数，所以函数的 this 是 dom1\nreturn function () &#123;\n    //有定时器就直接返回\n    if (timer) return;\n    //没有定时器就创建一个\n    timer = setTimeout(() => &#123;\n    //调用点击事件的操作，绑定到dom1上，arguments是点击事件\n    fn.apply(this, arguments);\n    // 清除定时器\n    timer = null;\n    &#125;, delay);\n&#125;;\n&#125;\ndom1.addEventListener(\"click\", throttle(point, 1000));\n防抖let dom2 = document.querySelector(\"#dom2\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\nlet dom2 = document.querySelector(\"#dom2\");\nfunction debounce(fn, delay) &#123;\nlet timer = null;\nreturn function () &#123;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => &#123;\n    fn.apply(this, arguments);\n    &#125;, delay);\n&#125;;\n&#125;\ndom2.addEventListener(\"click\", debounce(point, 1000));\nnewfunction myNew(fun,...arg)&#123;\n   // 创建一个对象\n   let instance = &#123;&#125;\n   // 对象的__proto__指向构造函数的prototype\n   instance.__proto__ = fun.prototype\n   // 改变构造函数的this指向，并传递参数\n   let person =  fun.call(instance,...arg)\n   //如果构造函数中手动返回一个对象，这个myNew将返回构造函数中的对象(我也不知道为什么要这样)\n   return typeof person===\"object\"? person:instance\n &#125;\n function Person(name) &#123;\n   this.name = name\n   // return &#123;a:'a'&#125;\n &#125;\n Person.prototype.sayName = function() &#123;\n   console.log(`My name is $&#123;this.name&#125;`)\n &#125;\n const me = myNew(Person, '小灵通')\n me.sayName()\n console.log(me)","slug":"手写代码","date":"2022-04-27T06:03:21.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"9f4d3521f710364c385149f2cdd3363c","title":"promise的基本用法","content":"promise 是干什么的promise是异步编程的一种解决方案\npromise的状态promise有三种状态\n\npending（进行中）\nfulfilled（已成功）\nrejected（已失败）\n\n状态一旦确定，就无法更改\n如何使用promisePromise对象是一个构造函数，用来生成Promise实例\nnew promise((resolve,reject)=>&#123;\n   \t//操作\n   &#125;)\n这样你就有了一个promise实例，promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject(这两个参数也是函数)\n\nresolve()函数的作用是将promise的状态从“未完成”变为“成功”\nreject()函数的作用是将promise的状态从“未完成”变为“失败”\n\n每当promise的状态改变，都会调用then()\nthen( )描述then()方法用于指定当前实例状态发生改变时的回调函数。它返回一个新的Promise实例。\n语法Promise.prototype.then(onFulfilled, onRejected);\n参数\n\n\n参数\n描述\n\n\n\nonFulfilled\n当前实例变成fulfilled状态时，该参数作为回调函数被调用。\n\n\nonRejected\n当前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n\n\n\n\n\n\n\n注意\nonFulfilled将接收一个参数，参数值由当前Promise实例内部的resolve()方法传值决定；onRejected将接收一个参数，参数值由当前Promise实例内部的reject()方法传值决定。\n\n例1： test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\") 或者 reject(\"失败\")\n &#125;)\n test1.then(\n //接受成功状态的回调\n \t(res)=>&#123;\n    \t\tconsole.log(res)//成功\n     &#125;,\n //接受失败状态的回调\n     (err)=>&#123;\n \t\t\t console.log(err)//失败\n \t&#125;\n )\n例2：由于在每个then中传入对失败状态进行处理的回调函数过于繁琐。这个例子中在最后对peomise的失败状态进行处理，前面每个then中没有传入对失败状态进行处理的回调函数，所以前面的then遇到错误会直接返回错误，不进行处理，知道遇到能处理的错误的then\n test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\")\n &#125;)\n  test1\n      .then((res) => &#123;\n        console.log(res);//成功\n        return new Promise((resolve, reject) => &#123;\n          resolve(\"内层promise成功\");\n        &#125;).then((res) => &#123;\n          console.log(res);//内层promise成功\n          return 1234;\n        &#125;);\n      &#125;)\n      .then((res) => console.log(res))//1234\n      //处理错误信息\n      .then(undefined,(res)=>&#123;\n         console.log(res)\n      &#125;)\ncatch( )描述catch() 方法返回一个Promise()，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。 (事实上, calling obj.catch(onRejected) 内部calls obj.then(undefined, onRejected)).说白了就是Promise.prototype.then(undefined, onRejected)的语法糖\n语法promise.prototype.catch(onRejected)\n参数\n\n\n参数\n描述\n\n\n\nonRejected\n前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n例3new promise((resolve,reject)=>&#123;\n   reject('失败')\n&#125;)\n.then(res=>console.log(res))//不会执行\n.catch(res=>console.log(res))//失败\nPromise.all()描述  Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息\n用法 const promise0 = [1, 2, 3].map((val) => &#123;\n  return new Promise((resolve, reject) => &#123;\n    setTimeout(() => &#123;\n      resolve(++val);\n    &#125;, 1000);\n  &#125;);\n&#125;);\nconst promise1 = new Promise((resolve, reject) => &#123;\n  reject(\"错误\");\n&#125;);\nPromise.all([...promise0, promise1])\n  .then((res) => console.log(res))\n  .catch((res) => console.log(res));\nPromise.race( )描述   race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。如果传的迭代是空的，则返回的 promise 将永远等待。如果迭代包含一个或多个非承诺值和&#x2F;或已解决&#x2F;拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。\n用法  let promise1 = new Promise((resolve, reject) => &#123;\n  setTimeout(() => &#123;\n    resolve(\"promise1 OK\");\n  &#125;, 1000);\n&#125;);\nlet promise2 = new Promise((resolve, reject) => &#123;\n  setTimeout(() => &#123;\n    resolve(\"promise2 OK\");\n  &#125;, 5000);\n&#125;);\nPromise.race([promise1, promise2])\n  .then((val) => &#123;\n    console.log(val);\n  &#125;)\n  .catch((err) => &#123;\n    console.log(err);\n  &#125;);\n  //封装\nfunction request(url, delay) &#123;\n  let promises = [\n    // 发请求\n    // axios.get(url),\n    //模拟请求，假设请求花了1秒钟\n    new Promise((resolve, reject) => &#123;\n      setTimeout(() => &#123;\n        resolve(\"请求成功\");\n      &#125;, 1000);\n    &#125;),\n    new Promise((resolve, reject) => &#123;\n      setTimeout(() => &#123;\n        reject(\"请求超时\");\n      &#125;, delay);\n    &#125;),\n  ];\n  return Promise.race(promises);\n&#125;\n//调用，两秒后请求超时\nrequest(\"url\", 2000)\n  .then((val) => &#123;\n    console.log(val);\n  &#125;)\n  .catch((err) => &#123;\n    console.log(err);\n  &#125;);","slug":"promise的基本用法","date":"2022-04-24T09:24:00.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"a43b2263eaca0865c9412baa1c8c6f53","title":"markdown 语法","content":"欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n全新的界面设计 ，将会带来全新的写作体验；\n在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；\n增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n全新的 KaTeX数学公式 语法；\n增加了支持甘特图的mermaid语法^1 功能；\n增加了 多屏幕编辑 Markdown文章功能；\n增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；\n增加了 检查列表 功能。\n\n\n功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G\n合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n如何改变文本的样式强调文本 强调文本\n加粗文本 加粗文本\n&#x3D;&#x3D;标记文本&#x3D;&#x3D;\n删除文本\n\n\n\n\n\n\n\n\n\n引用文本\nH2O is是液体。\n2^10^ 运算结果是 1024.\n插入链接与图片链接: link.\n图片: \n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &#x3D;30x30)\n居中的图片: \n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center &#x3D;30x30)\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.\n// An highlighted block\nvar foo = 'bar';\n\n生成一个适合你的列表\n项目\n项目\n项目\n\n\n\n\n\n\n项目1\n项目2\n项目3\n\n\n 计划任务\n 完成任务\n\n创建一个表格一个简单的表格是这么创建的：\n\n\n\n项目\nValue\n\n\n\n电脑\n$1600\n\n\n手机\n$12\n\n\n导管\n$1\n\n\n设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右\n\n\n\n第一列\n第二列\n第三列\n\n\n\n第一列文本居中\n第二列文本居右\n第三列文本居左\n\n\nSmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n\n\n\nTYPE\nASCII\nHTML\n\n\n\nSingle backticks\n&#39;Isn&#39;t this fun?&#39;\n‘Isn’t this fun?’\n\n\nQuotes\n&quot;Isn&#39;t this fun?&quot;\n“Isn’t this fun?”\n\n\nDashes\n-- is en-dash, --- is em-dash\n– is en-dash, — is em-dash\n\n\n创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors:  JohnLuke如何创建一个注脚一个具有注脚的文本。^2\n注释也是必不可少的Markdown将文本转换为 HTML。\n*[HTML]:   超文本标记语言\nKaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) &#x3D; (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分\n$$\\Gamma(z) &#x3D; \\int_0^\\infty t^{z-1}e^{-t}dt,.$$\n\n\n\n\n\n\n\n\n\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n新的甘特图功能，丰富你的文章gantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n\n关于 甘特图 语法，参考 这儿,\n\nUML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n\n这将产生一个流程图。:\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D&#123;菱形&#125;\nC --> D\n\n\n关于 Mermaid 语法，参考 这儿,\n\nFLowchart流程图我们依旧会支持flowchart的流程图：\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n\n\n关于 Flowchart流程图 语法，参考 这儿.\n\n导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。\n导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。\n","slug":"如何使用-hexo-写文章","date":"2022-04-23T12:12:13.000Z","categories_index":"","tags_index":"","author_index":"HLT"}]