[{"id":"8cb2b3268d741ec8cb2f77e2fe593594","title":"手写代码","content":"面试出场率及高的手写代码节流let dom1 = document.querySelector(\"#dom1\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\n//第一个参数为 点击事件的操作函数 第二个参数为 延迟操作的时间\nfunction throttle(fn, delay) &#123;\n//定义一个定时器变量  用于判断点击时是否有定时器\nlet timer = null;\n//返回一个函数，每次点击 就会调用这个函数，所以函数的 this 是 dom1\nreturn function () &#123;\n    //有定时器就直接返回\n    if (timer) return;\n    //没有定时器就创建一个\n    timer = setTimeout(() => &#123;\n    //调用点击事件的操作，绑定到dom1上，arguments是点击事件\n    fn.apply(this, arguments);\n    // 清除定时器\n    timer = null;\n    &#125;, delay);\n&#125;;\n&#125;\ndom1.addEventListener(\"click\", throttle(point, 1000));\n防抖let dom2 = document.querySelector(\"#dom2\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\nlet dom2 = document.querySelector(\"#dom2\");\nfunction debounce(fn, delay) &#123;\nlet timer = null;\nreturn function () &#123;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => &#123;\n    fn.apply(this, arguments);\n    &#125;, delay);\n&#125;;\n&#125;\ndom2.addEventListener(\"click\", debounce(point, 1000));\nnewfunction myNew(fun,...arg)&#123;\n   // 创建一个对象\n   let instance = &#123;&#125;\n   // 对象的__proto__指向构造函数的prototype\n   instance.__proto__ = fun.prototype\n   // 改变构造函数的this指向，并传递参数\n   let person =  fun.call(instance,...arg)\n   //如果构造函数中手动返回一个对象，这个myNew将返回构造函数中的对象(我也不知道为什么要这样)\n   return typeof person===\"object\"? person:instance\n &#125;\n function Person(name) &#123;\n   this.name = name\n   // return &#123;a:'a'&#125;\n &#125;\n Person.prototype.sayName = function() &#123;\n   console.log(`My name is $&#123;this.name&#125;`)\n &#125;\n const me = myNew(Person, '小灵通')\n me.sayName()\n console.log(me)","slug":"手写代码","date":"2022-04-27T06:03:21.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"9f4d3521f710364c385149f2cdd3363c","title":"promise的基本用法","content":"promise 是干什么的promise是异步编程的一种解决方案\npromise的状态promise有三种状态\n\npending（进行中）\nfulfilled（已成功）\nrejected（已失败）\n\n状态一旦确定，就无法更改\n如何使用promisePromise对象是一个构造函数，用来生成Promise实例\nnew promise((resolve,reject)=>&#123;\n   \t//操作\n   &#125;)\n这样你就有了一个promise实例，promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject(这两个参数也是函数)\n\nresolve()函数的作用是将promise的状态从“未完成”变为“成功”\nreject()函数的作用是将promise的状态从“未完成”变为“失败”\n\n每当promise的状态改变，都会调用then()\nthen( )描述then()方法用于指定当前实例状态发生改变时的回调函数。它返回一个新的Promise实例。\n语法Promise.prototype.then(onFulfilled, onRejected);\n参数\n\n\n参数\n描述\n\n\n\nonFulfilled\n当前实例变成fulfilled状态时，该参数作为回调函数被调用。\n\n\nonRejected\n当前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n\n\n\n\n\n\n\n注意\nonFulfilled将接收一个参数，参数值由当前Promise实例内部的resolve()方法传值决定；onRejected将接收一个参数，参数值由当前Promise实例内部的reject()方法传值决定。\n\n例1： test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\") 或者 reject(\"失败\")\n &#125;)\n test1.then(\n //接受成功状态的回调\n \t(res)=>&#123;\n    \t\tconsole.log(res)//成功\n     &#125;,\n //接受失败状态的回调\n     (err)=>&#123;\n \t\t\t console.log(err)//失败\n \t&#125;\n )\n例2：由于在每个then中传入对失败状态进行处理的回调函数过于繁琐。这个例子中在最后对peomise的失败状态进行处理，前面每个then中没有传入对失败状态进行处理的回调函数，所以前面的then遇到错误会直接返回错误，不进行处理，知道遇到能处理的错误的then\n test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\")\n &#125;)\n  test1\n      .then((res) => &#123;\n        console.log(res);//成功\n        return new Promise((resolve, reject) => &#123;\n          resolve(\"内层promise成功\");\n        &#125;).then((res) => &#123;\n          console.log(res);//内层promise成功\n          return 1234;\n        &#125;);\n      &#125;)\n      .then((res) => console.log(res))//1234\n      //处理错误信息\n      .then(undefined,(res)=>&#123;\n         console.log(res)\n      &#125;)\ncatch( )描述catch() 方法返回一个Promise()，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。 (事实上, calling obj.catch(onRejected) 内部calls obj.then(undefined, onRejected)).说白了就是Promise.prototype.then(undefined, onRejected)的语法糖\n语法promise.prototype.catch(onRejected)\n参数\n\n\n参数\n描述\n\n\n\nonRejected\n前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n例3new promise((resolve,reject)=>&#123;\n   reject('失败')\n&#125;)\n.then(res=>console.log(res))//不会执行\n.catch(res=>console.log(res))//失败\n\n\n\n","slug":"promise的基本用法","date":"2022-04-24T09:24:00.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"a43b2263eaca0865c9412baa1c8c6f53","title":"markdown 语法","content":"欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n全新的界面设计 ，将会带来全新的写作体验；\n在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；\n增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n全新的 KaTeX数学公式 语法；\n增加了支持甘特图的mermaid语法^1 功能；\n增加了 多屏幕编辑 Markdown文章功能；\n增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；\n增加了 检查列表 功能。\n\n\n功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G\n合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n如何改变文本的样式强调文本 强调文本\n加粗文本 加粗文本\n&#x3D;&#x3D;标记文本&#x3D;&#x3D;\n删除文本\n\n\n\n\n\n\n\n\n\n引用文本\nH2O is是液体。\n2^10^ 运算结果是 1024.\n插入链接与图片链接: link.\n图片: \n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &#x3D;30x30)\n居中的图片: \n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center &#x3D;30x30)\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.\n// An highlighted block\nvar foo = 'bar';\n\n生成一个适合你的列表\n项目\n项目\n项目\n\n\n\n\n\n\n项目1\n项目2\n项目3\n\n\n 计划任务\n 完成任务\n\n创建一个表格一个简单的表格是这么创建的：\n\n\n\n项目\nValue\n\n\n\n电脑\n$1600\n\n\n手机\n$12\n\n\n导管\n$1\n\n\n设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右\n\n\n\n第一列\n第二列\n第三列\n\n\n\n第一列文本居中\n第二列文本居右\n第三列文本居左\n\n\nSmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n\n\n\nTYPE\nASCII\nHTML\n\n\n\nSingle backticks\n&#39;Isn&#39;t this fun?&#39;\n‘Isn’t this fun?’\n\n\nQuotes\n&quot;Isn&#39;t this fun?&quot;\n“Isn’t this fun?”\n\n\nDashes\n-- is en-dash, --- is em-dash\n– is en-dash, — is em-dash\n\n\n创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors:  JohnLuke如何创建一个注脚一个具有注脚的文本。^2\n注释也是必不可少的Markdown将文本转换为 HTML。\n*[HTML]:   超文本标记语言\nKaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) &#x3D; (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分\n$$\\Gamma(z) &#x3D; \\int_0^\\infty t^{z-1}e^{-t}dt,.$$\n\n\n\n\n\n\n\n\n\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n新的甘特图功能，丰富你的文章gantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n\n关于 甘特图 语法，参考 这儿,\n\nUML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n\n这将产生一个流程图。:\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D&#123;菱形&#125;\nC --> D\n\n\n关于 Mermaid 语法，参考 这儿,\n\nFLowchart流程图我们依旧会支持flowchart的流程图：\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n\n\n关于 Flowchart流程图 语法，参考 这儿.\n\n导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。\n导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。\n","slug":"如何使用-hexo-写文章","date":"2022-04-23T12:12:13.000Z","categories_index":"","tags_index":"","author_index":"HLT"}]