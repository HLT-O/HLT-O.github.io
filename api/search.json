[{"id":"ce01ca98a6449b03113a31764fa5119c","title":"跨域问题及解决方案","content":"跨域问题及解决方案同源策略及跨域问题同源策略是一套浏览器安全机制，当一个源的文档和脚本，与另一个源的资源进行通信时，同源策略就会对这个通信做出不同程度的限制。\n简单来说，同源策略对 同源资源 放行，对 异源资源 限制\n因此限制造成的开发问题，称之为跨域（异源）问题\n同源和异源源(origin) &#x3D; 协议 + 域名 + 端口\n\n例如:\nhttps://study.duyiedu.com/api/movie的源为https://study.duyiedu.com\nhttp://localhost:7001/index.html的源为http://localhost:7001\n两个URL地址的源完全相同，则称之为同源，否则称之为异源（跨域）\n\n跨域出现的场景跨域可能出现在三种场景：\n\n网络通信\na元素的跳转；加载css、js、图片等；AJAX等等\n\nJS API\nwindow.open、window.parent、iframe.contentWindow等等\n\n存储\nWebStorage、IndexedDB等等\n\n\n对于不同的跨域场景，以及每个场景中不同的跨域方式，同源策略都有不同的限制。\n本文重点讨论网络通信中AJAX的跨域问题\n网络中的跨域当浏览器运行页面后，会发出很多的网络请求，例如CSS、JS、图片、AJAX等等\n请求页面的源称之为页面源，在该页面中发出的请求称之为目标源。\n当页面源和目标源一致时，则为同源请求，否则为异源请求（跨域请求）\n\n浏览器如何限制异源请求？浏览器出于多方面的考量，制定了非常繁杂的规则来限制各种跨域请求，但总体的原则非常简单：\n\n对标签发出的跨域请求轻微限制\n对AJAX发出的跨域请求严厉限制\n\n\n解决方案CORSCORS（Cross-Origin Resource Sharing）是最正统的跨域解决方案，同时也是浏览器推荐的解决方案。\nCORS是一套规则，用于帮助浏览器判断是否校验通过。\n\nCORS的基本理念是：\n\n只要服务器明确表示允许，则校验通过\n服务器明确拒绝或没有表示，则校验不通过\n\n所以，使用CORS解决跨域，必须要保证服务器是「自己人」\n请求分类CORS将请求分为两类：&#x3D;&#x3D;简单请求&#x3D;&#x3D;和&#x3D;&#x3D;预检请求&#x3D;&#x3D;。\n对不同种类的请求它的规则有所区别。\n所以要理解CORS，首先要理解它是如何划分请求的。\n简单请求\n\n\n\n\n\n\n\n\n完整判定逻辑：https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests\n简单来说，只要全部满足下列条件，就是简单请求：\n\n请求方法是GET、POST、HEAD之一\n\n头部字段满足CORS安全规范，详见 W3C\n\n\n\n\n\n\n\n\n\n浏览器默认自带的头部字段都是满足安全规范的，只要开发者不改动和新增头部，就不会打破此条规则\n\n如果有Content-Type，必须是下列值中的一个\n\ntext/plain\nmultipart/form-data\napplication/x-www-form-urlencoded\n\n\n\n预检请求(preflight)只要不是简单请求，均为预检请求\n练习// 下面的跨域请求哪些是简单请求，哪些是预检请求\n\n// 1\nfetch('https://douyin.com');\n\n// 2\nfetch('https://douyin.com', &#123;\n  headers: &#123;\n    a: 1,\n  &#125;,\n&#125;);\n\n// 3\nfetch('https://douyin.com', &#123;\n  method: 'POST',\n  body: JSON.stringify(&#123; a: 1, b: 2 &#125;),\n&#125;);\n\n// 4\nfetch('https://douyin.com', &#123;\n  method: 'POST',\n  headers: &#123;\n    'content-type': 'application/json',\n  &#125;,\n  body: JSON.stringify(&#123; a: 1, b: 2 &#125;),\n&#125;);\n\n对简单请求的验证\n对预检请求的验证\n发送预检请求\n\n\n\n发送真实请求（和简单请求一致）\n\n细节1 - 关于cookie默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行\n不过可以通过简单的配置就可以实现附带cookie\n// xhr\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n// fetch api\nfetch(url, &#123;\n  credentials: \"include\"\n&#125;)\n\n这样一来，该跨域的ajax请求就是一个附带身份凭证的请求\n当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段\n而服务器响应时，需要明确告知客户端：服务器允许这样的凭据\n告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials: true即可\n对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。\n另外要特别注意的是：**对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为**。这就是为什么不推荐使用的原因\n细节2 - 关于跨域获取响应头在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\nAccess-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，例如：\nAccess-Control-Expose-Headers: authorization, a, b\n\n这样JS就能够访问指定的响应头了。\nJSONP在很久很久以前…并没有CORS方案\n\n在那个年代，古人靠着非凡的智慧来解决这一问题\n\n虽然可以解决问题，但JSONP有着明显的缺陷：\n\n仅能使用GET请求\n\n容易产生安全隐患\n\n\n\n\n\n\n\n\n\n恶意攻击者可能利用callback=恶意函数的方式实现XSS攻击\n\n容易被非法站点恶意调用\n\n\n因此，除非是某些特殊的原因，否则永远不应该使用JSONP\n代理CORS和JSONP均要求服务器是「自己人」\n那如果不是呢？\n\n\n那就找一个中间人（代理）\n\n比如，前端小王想要请求获取王者荣耀英雄数据，但直接请求腾讯服务器会造成跨域\n\n由于腾讯服务器不是「自己人」，小王决定用代理解决\n\n如何选择最重要的，是要保持生产环境和开发环境一致\n下面是一张决策图\n\n具体的几种场景\n\n\n","slug":"跨域问题及解决方案","date":"2023-04-25T14:26:39.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"9afd3519d234e5d16b412f84ce601c21","title":"浏览器事件循环","content":"事件循环浏览器的进程模型何为进程？程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程\n\n\n每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。\n何为线程？有了进程后，就可以运行程序的代码了。\n运行代码的「人」称之为「线程」。\n一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。\n如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。\n\n浏览器有哪些进程和线程？浏览器是一个多进程多线程的应用程序\n浏览器内部工作极其复杂。\n为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。\n\n\n\n\n\n\n\n\n\n\n可以在浏览器的任务管理器中查看当前的所有进程\n其中，最主要的进程有：\n\n浏览器进程\n主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。\n\n网络进程\n负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。\n\n渲染进程（本节课重点讲解的进程）\n渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。\n默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。\n\n\n\n\n\n\n\n\n\n将来该默认模式可能会有所改变，有兴趣的同学可参见chrome官方说明文档\n\n\n渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：\n\n解析 HTML\n解析 CSS\n计算样式\n布局\n处理图层\n每秒把页面画 60 次\n执行全局 JS 代码\n执行事件处理函数\n执行计时器的回调函数\n……\n\n\n\n\n\n\n\n\n\n\n思考题：为什么渲染进程不适用多个线程来处理这些事情？\n要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？\n比如：\n\n我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？\n我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？\n浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？\n……\n\n渲染主线程想出了一个绝妙的主意来处理这个问题：排队\n\n\n在最开始的时候，渲染主线程会进入一个无限循环\n每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。\n其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务\n\n这样一来，就可以让每个任务有条不紊的、持续的进行下去了。\n整个过程，被称之为事件循环（消息循环）\n若干解释何为异步？代码在执行过程中，会遇到一些无法立即处理的任务，比如：\n\n计时完成后需要执行的任务 —— setTimeout、setInterval\n网络通信完成后需要执行的任务 – XHR、Fetch\n用户操作后需要执行的任务 – addEventListener\n\n如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」\n\n渲染主线程承担着极其重要的工作，无论如何都不能阻塞！\n因此，浏览器选择异步来解决这个问题\n\n使用异步的方式，渲染主线程永不阻塞\n\n\n\n\n\n\n\n\n\n面试题：如何理解 JS 的异步？\n参考答案：\nJS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。\n而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。\n如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。\n所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。\n在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。\nJS为何会阻碍渲染？先看代码\n&lt;h1>Mr.Yuan is awesome!&lt;/h1>\n&lt;button>change&lt;/button>\n&lt;script>\n  var h1 = document.querySelector('h1');\n  var btn = document.querySelector('button');\n\n  // 死循环指定的时间\n  function delay(duration) &#123;\n    var start = Date.now();\n    while (Date.now() - start &lt; duration) &#123;&#125;\n  &#125;\n\n  btn.onclick = function () &#123;\n    h1.textContent = '袁老师很帅！';\n    delay(3000);\n  &#125;;\n&lt;/script>\n\n点击按钮后，会发生什么呢？\n&lt;见具体演示&gt;\n任务有优先级吗？任务没有优先级，在消息队列中先进先出\n但消息队列是有优先级的\n根据 W3C 的最新解释:\n\n每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。\n浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\n\n\n\n\n\n\n\n\n\n\n随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法\n在目前 chrome 的实现中，至少包含了下面的队列：\n\n延时队列：用于存放计时器到达后的回调任务，优先级「中」\n交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」\n微队列：用户存放需要最快执行的任务，优先级「最高」\n\n\n\n\n\n\n\n\n\n\n添加任务到微队列的主要方式主要是使用 Promise、MutationObserver\n例如：\n// 立即把一个函数添加到微队列\nPromise.resolve().then(函数)\n\n\n\n\n\n\n\n\n\n浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑\n\n\n\n\n\n\n\n\n\n面试题：阐述一下 JS 的事件循环\n参考答案：\n事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。\n在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。\n过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。\n根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。\n\n\n\n\n\n\n\n\n\n面试题：JS 中的计时器能做到精确计时吗？为什么？\n参考答案：\n不行，因为：\n\n计算机硬件没有原子钟，无法做到精确计时\n操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差\n按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差\n受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差\n\n最后单线程是产生异步的原因\n事件循环是实现异步的方式\n","slug":"浏览器事件循环","date":"2023-04-25T14:24:03.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"dce1cac53fd6e8ec39372d20a981521f","title":"CSS之包含块","content":"你不知道的 CSS 之包含块一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。\n但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。\n\n\n好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。\n\n\n包含块英语全称为containing block，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：\nhttps://drafts.csswg.org/css2/#containing-block-details\n\n\n并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。\n那么，这个包含块究竟说了什么内容呢？\n说起来也简单，就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。\n来吧，少年，让我们从最简单的 case 开始看。\n\n\n&lt;body>\n  &lt;div class=\"container\">\n    &lt;div class=\"item\">&lt;/div>\n  &lt;/div>\n&lt;/body>\n\n.container&#123;\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n&#125;\n.item&#123;\n  width: 50%;\n  height: 50%;\n  background-color: red;\n&#125;\n\n请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？\n\n\n相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。\n这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。\n这个答案实际上是不准确的。正确的答案应该是，div.item 的宽高是根据它的包含块来计算的，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。\n因此正如我前面所说，很多时候你都感受不到包含块的存在。\n包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（initial containing block）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。\n另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：\n\n如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。\n如果 position 属性是 fixed，那么包含块由视口建立。\n如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。\n\n前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：\n&lt;body>\n    &lt;div class=\"container\">\n      &lt;div class=\"item\">\n        &lt;div class=\"item2\">&lt;/div>\n      &lt;/div>\n    &lt;/div>\n  &lt;/body>\n\n.container &#123;\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n  position: relative;\n&#125;\n.item &#123;\n  width: 300px;\n  height: 150px;\n  border: 5px solid;\n  margin-left: 100px;\n&#125;\n.item2 &#123;\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  position: absolute;\n  left: 10px;\n  top: 10px;\n&#125;\n\n首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。\n公布正确答案：\n\n\n怎么样？有没有和你所想象的对上？\n其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。\n如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。\n实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：\n\ntransform 或 perspective 的值不是 none\nwill-change 的值是 transform 或 perspective \nfilter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效). \ncontain 的值是 paint (例如: contain: paint;)\n\n我们还是来看一个示例：\n&lt;body>\n  &lt;div class=\"container\">\n    &lt;div class=\"item\">\n      &lt;div class=\"item2\">&lt;/div>\n    &lt;/div>\n  &lt;/div>\n&lt;/body>\n\n.container &#123;\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n  position: relative;\n&#125;\n.item &#123;\n  width: 300px;\n  height: 150px;\n  border: 5px solid;\n  margin-left: 100px;\n  transform: rotate(0deg); /* 新增代码 */\n&#125;\n.item2 &#123;\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  position: absolute;\n  left: 10px;\n  top: 10px;\n&#125;\n\n我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：\n\n\n可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。\n好了，到这里，关于包含块的知识就基本讲完了。\n\n\n我们再把 CSS 规范中所举的例子来看一下。\n&lt;html>\n  &lt;head>\n    &lt;title>Illustration of containing blocks&lt;/title>\n  &lt;/head>\n  &lt;body id=\"body\">\n    &lt;div id=\"div1\">\n      &lt;p id=\"p1\">This is text in the first paragraph...&lt;/p>\n      &lt;p id=\"p2\">\n        This is text\n        &lt;em id=\"em1\">\n          in the\n          &lt;strong id=\"strong1\">second&lt;/strong>\n          paragraph.\n        &lt;/em>\n      &lt;/p>\n    &lt;/div>\n  &lt;/body>\n&lt;/html>\n\n上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？\n对应的结果如下：\n\n\n\n元素\n包含块\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\nbody\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\np2\n\n\nstrong1\np2\n\n\n首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。\n不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：\n\n如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。\n\n没错，因为 em1 不是块容器，而包含块是离它最近的块容器的内容区域，所以是 p2。\n接下来添加如下的 CSS：\n#div1 &#123; \n  position: absolute; \n  left: 50px; top: 50px \n&#125;\n\n上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。\n答案如下：\n\n\n\n元素\n包含块\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\ninitial C.B. (UA-dependent)\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\np2\n\n\nstrong1\np2\n\n\n可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：\n\n初始包含块（initial containing block）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。\n如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。\n\n是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。\n接下来我们继续修改我们的 CSS：\n#div1 &#123; \n  position: absolute; \n  left: 50px; \n  top: 50px \n&#125;\n#em1  &#123; \n  position: absolute; \n  left: 100px; \n  top: 100px \n&#125;\n\n这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？\n没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。\n如下表所示：\n\n\n\n元素\n包含块\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\ninitial C.B. (UA-dependent)\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\ndiv1（因为定位了，参阅非根元素包含块确定规则的第三条）\n\n\nstrong1\nem1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）\n\n\n好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。\n\n\n另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。\n具体你可以移步到：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block\n好了，这就是有关包含块的所有内容了，你学会了么？-）\n\n-EOF-\n","slug":"CSS之包含块","date":"2023-04-25T14:21:40.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"178582872a3345648c989f9b6330a9d1","title":"浏览器渲染原理","content":"浏览器渲染原理浏览器是如何渲染页面的？当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。\n在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。\n\n整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画\n每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。\n这样，整个渲染流程就形成了一套组织严密的生产流水线。\n\n渲染的第一步是解析 HTML。\n解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。\n如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。\n如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。\n第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。\n优先执行JS的话，如果JS中操作了还没生成DOM怎么办?????\n\n渲染的下一步是样式计算。\n主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。\n在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px\n这一步完成后，会得到一棵带有样式的 DOM 树。\n\n接下来是布局，布局完成后会得到布局树。\n布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。\n大部分时候，DOM 树和布局树并非一一对应。 \n比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。\n\n下一步是分层\n主线程会使用一套复杂的策略对整个布局树中进行分层。\n分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。\n滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。\n\n再下一步是绘制\n主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。\n\n完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。\n合成线程首先对每个图层进行分块，将其划分为更多的小区域。\n它会从线程池中拿取多个线程来完成分块工作。\n\n分块完成后，进入光栅化阶段。\n合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。\nGPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。\n光栅化的结果，就是一块一块的位图\n\n最后一个阶段就是画了\n合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。\n指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。\n变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。\n合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。\n什么是 reflow？reflow 的本质就是重新计算 layout 树。\n当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。\n为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。\n也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。\n浏览器在反复权衡下，最终决定获取属性立即 reflow。\n什么是 repaint？repaint 的本质就是重新根据分层信息计算了绘制指令。\n当改动了可见样式后，就需要重新计算，会引发 repaint。\n由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。\n为什么 transform 的效率高？因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段\n由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。\n","slug":"浏览器渲染原理","date":"2023-04-25T14:18:29.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"77098c3ba710b162837eee255527cd8e","title":"commonJs与ESModule的区别","content":"CommonJsCommonJS是Node.js使用的模块规范，在 Node.js 模块系统中，每个文件都被视为独立的模块(对象)，模块的本地变量将是私有的。\n浏览器中不可使用, 浏览器并没有实现CommonJS\nCommonJS的导出CommonJs使用exports和module.exports导出模块\n============ module.js 文件 ============\n \nlet _moduleName = \"module\";\nfunction setModuleName(name) &#123;\n  _moduleName = name;\n&#125;\nfunction getModuleName() &#123;\n  return _moduleName;\n&#125;\nmodule.exports = &#123; setModuleName, getModuleName &#125;;\n//或\n// exports.setModuleName = setModuleName\n// exports.getModuleName = getModuleName\n \nexports和module.exports的区别两者没有区别，exports和module.exports指向的是同一个引用地址\nexports = module.exports //true\n\n\n\n\n\n\n\n注意\n    不能使用 exports &#x3D; XXX ，改变了内存地址，导致exports ！&#x3D; module.exports\n\nCommonJS的导入CommonJs使用使用require()导入模块\n============ 导入 module.js ============\n \n const moduleJS = require(\"module.js\")\n moduleJS.setModuleName('123')\n let moduleName = moduleJS.getModuleName()//123\nCommonJs导入模块的查找规则导入格式：require(X)情况一：X是一个Node核心模块(内置模块)，比如path、http\n\n直接返回内置模块，并且停止查找\n\n情况二：X是以 .&#x2F; 或 …&#x2F; 或 &#x2F;（根目录）开头的第一步：将X当做一个文件在对应的目录下查找；\n\n如果有x后缀名，按照后缀名的格式查找对应的文件\n\n如果没有后缀名，会按照如下顺序：\n\n直接查找文件X \n查找X.js文件\n查找X.json文件\n查找X.node文件\n\n\n\n第二步：没有找到对应的文件，将X作为一个目录\n\n查找目录下面的index文件\n\n查找X&#x2F;index.js文件\n查找X&#x2F;index.json文件\n查找X&#x2F;index.node文件\n\n\n没有找到，那么报错：not found\n\n\n情况三：X为第三方库名称（不是核心模块，也不是.&#x2F;等格式）这时会去node_modules文件夹中去寻找\n如果当前文件夹没找到node_modules文件夹, 就会去上层文件夹找, 一层一层的寻找, 以此类推, 找不到就会报错\nCommonJs导入模块的方式 CommonJs中 require()方法导入模块是对模块的浅拷贝下面来求证：\n/************ module.js ************/\n\n   let a = 1 , b = &#123;&#125;\n   setTimeout(()=>&#123;\n       a = 2\n       b.name = 'b'\n   &#125;,500)\n   module.exports = &#123;\n       a,b\n   &#125;\n\n/************ main.js ************/\n   let app = require('./module.js')\n   console.log(\"app = \",app)\n   setTimeout(()=>&#123;\n       console.log(\"1s后:\");\n       console.log(\"app = \",app)\n   &#125;,1000)\n\n运行main.js后得到以下结果：\napp = &#123; a: 1, b: &#123;&#125; &#125;\n1s后：\napp = &#123; a: 1, b: &#123; name: 'b' &#125; &#125;\n可见：app中属性a没有发生改变，但身为对象的属性b发生了改变得出结论：require()方法导入模块是对模块的浅拷贝\n模块加载过程模块在被第一次引入时，模块中的js代码会被运行一次，并缓存模块被多次引入时，因为已被缓存，最终只加载（运行）一次\n\n这是因为每个模块对象module都有一个属性：loaded。为false表示还没有加载，为true表示已经加载；\n\n如果有循环引入，那么加载顺序是什么？如下：\n/************ main.js文件 ************/\n  console.log('main')\n  require(\"./aa\")\n  require('./bb')\n\n/************ aa.js文件 ************/\n  console.log('aa')\n  require('./ccc')\n\n/************ bb.js文件 ************/\n  console.log('bb')\n  require('./cc')\n  require('./ee')\n\n/************ cc.js文件 ************/\n  console.log('cc')\n  require('./dd')\n\n/************ dd.js文件 ************/\n  console.log('dd')\n  require('./ee')\n\n/************ ee.js文件 ************/\n  console.log('ee')\n\n引用关系图如下\n这个其实是一种数据结构：图结构；图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）Node采用的是深度优先算法：main -&gt; aa -&gt; cc -&gt; dd -&gt; ee -&gt; bb\n所以执行main.js文件的结果为：\nmain\naa\ncc\ndd\nee\nbb\n\nCommonJS规范缺点CommonJS加载模块是同步的\n\n同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；\n这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；\n\n如果将CommonJS规范应用于浏览器\n\n浏览器加载js文件需要先从服务器将文件下载下来，之后再加载运行；\n那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；\n\nESModuleESModule（简称ESM）是一种JavaScript模块系统，是目前JavaScript官方推荐的模块化方案。ESM支持静态导入和导出，可以在编译时确定模块的依赖关系，减少了运行时的计算量，提高了性能。与CommonJS模块不同，ESM是采用严格模式的，模块内部的变量不会污染全局作用域。此外，ESM还支持动态导入，允许在运行时根据需要动态加载模块。\nESModule的导出和导入ESModule的导出方式有三种\n1.命名导出（Named Exports）/************ module.js文件 ************/\n  export const name = \"Tom\";\n  export function sayHi() &#123;\n    console.log(\"Hi!\");\n  &#125;\n  export class Person &#123;\n    constructor(name) &#123;\n      this.name = name;\n    &#125;\n    sayHello() &#123;\n      console.log(`Hello, $&#123;this.name&#125;!`);\n    &#125;\n  &#125;\n\n/************ main.js文件 ************/\n  import &#123; name, sayHi, Person &#125; from \"./module.js\";\n  console.log(name); // \"Tom\"\n  sayHi(); // \"Hi!\"\n  const person = new Person(\"Jack\");\n  person.sayHello(); // \"Hello, Jack!\"\n\n命名导出的简写方式，又称为批量导出（Export List）\n/************ module.js文件 ************/\n  const name = \"Tom\";\n  function hello() &#123;\n    console.log(\"Hello!\");\n  &#125;\n  class Person &#123;\n    constructor(name) &#123;\n      this.name = name;\n    &#125;\n    sayHello() &#123;\n      console.log(`Hello, $&#123;this.name&#125;!`);\n    &#125;\n  &#125;\n  export &#123; name, hello, Person &#125;;\n\n/************ main.js文件 ************/\n  import &#123; name, hello, Person &#125; from \"./module.js\";\n  console.log(name); // \"Tom\"\n  hello(); // \"Hello!\"\n  const person = new Person(\"Jack\");\n  person.sayHello(); // \"Hello, Jack!\"\n\n2.默认导出（Default Exports）/************ module.js文件 ************/\n  export default function sayHi(name) &#123;\n    console.log(`Hi, $&#123;name&#125;!`);\n  &#125;\n\n/************ main.js文件 ************/\n  import sayHi from \"./module.js\";\n  sayHi(\"Tom\"); // \"Hi, Tom!\"\n默认导出只能导出一个接口。一个模块只能有一个默认导出。这是因为在默认导出中，没有指定名称，只能用默认名称 default 进行引用。\n3.混合导出（Mixed Exports）混合导出是指在一个模块中既有命名导出，又有默认导出。这种情况下，可以将命名导出和默认导出混合使用。例如：\n/************ module.js文件 ************/\n  export const name = \"Tom\";\n  export default function sayHi() &#123;\n    console.log(\"Hi!\");\n  &#125;\n\n/************ main.js文件 ************/\n  import sayHi, &#123; name &#125; from \"./module.js\";\n  console.log(name); // \"Tom\"\n  sayHi(); // \"Hi!\"\n\n需要注意的是，混合导出虽然方便，但容易导致混淆和命名冲突。推荐在一个模块中只使用一种导出方式。\n其他导出导入写法重定向导出可以把当前模块作为一个中转站，一方面引入 module 内的属性，然后把属性再给导出去。\nexport * from 'module' // 第一种方式\nexport &#123; name, author, ..., say &#125; from 'module' // 第二种方式\nexport &#123;   name as bookName ,  author as bookAuthor , ..., say &#125; from 'module' //第三种方式\n\n第一种方式：重定向导出 module 中的所有导出属性， 但是不包括 module 内的 default 属性。\n第二种方式：从 module 中导入 name ，author ，say 再以相同的属性名，导出。\n第三种方式：从 module 中导入 name ，重属名为 bookName 导出，从 module 中导入 author ，重属名为 bookAuthor 导出，正常导出 say 。\n\n我也不知道有什么用，暂时没用上这些写法\n无需导入模块，只运行模块import 'module'\n\n执行 module 不导出值 多次调用 module 只运行一次。\n\n动态导入const promise = import('module')\n\nimport(‘module’) ，动态导入返回一个 Promise。为了支持这种方式，需要在 webpack 中做相应的配置处理。\n\nESModule导入模块的查找规则导入格式：import &#123; name &#125; from &quot;X&quot;情况一：X是一个Node核心模块(内置模块)，比如path、http、fs例如：import &#123; readFile &#125; from &quot;fs&quot;\n\n直接返回内置模块，并且停止查找\n\n情况二：X是以 .&#x2F; 或 …&#x2F; 或 &#x2F;（根目录）开头的例如：import &#123; name &#125; from &quot;./module.js\n\n相对路径或绝对路径的模块，会根据路径查找对应的模块文件\n\n情况三：X为第三方库名称（不是核心模块，也不是.&#x2F;等格式）例如：import &#123; Button &#125; from &#39;element-ui&#39;这时会去node_modules文件夹中去寻找\n如果当前文件夹没找到node_modules文件夹或node_modules文件夹中没有, 就会去上层文件夹找, 一层一层的寻找, 以此类推, 找不到就会报错\n需要注意的是，ESModule的查找规则与CommonJS模块的查找规则不同。在CommonJS模块中，模块的查找是基于文件系统的，而在ESModule中，模块的查找是基于模块标识符的。并且在ESModule中，模块的查找是静态的，即在编译时就已经确定了模块的依赖关系。\nESModule 特性1 静态语法ES6 module 的引入和导出是静态的，import 会自动提升到代码的顶层 ，import , export 不能放在块级作用域或条件语句中。这种静态语法，在编译过程中确定了导入和导出的关系，所以更方便去查找依赖，更方便去 tree shaking (摇树) ， 可以使用 lint 工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查。\n2 执行特性ES6 module 和 Common.js 一样，对于相同的 js 文件，会保存静态属性。\n但是与 Common.js 不同的是 ，CommonJS 模块同步加载并执行模块文件，ES6 模块提前加载并执行模块文件，ES6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历。\n为了验证这一点，看一下如下 demo。\n/************ main.js文件 ************/\n  console.log('main.js开始执行')\n  import say from './a'\n  import say1 from './b'\n  console.log('main.js执行完毕')\n\n/************ a.js文件 ************/\n  import b from './b'\n  console.log('a模块加载')\n  export default  function say ()&#123;\n      console.log('hello , world')\n  &#125;\n\n/************ b.js文件 ************/\n  console.log('b模块加载')\n  export default function sayhello()&#123;\n      console.log('hello,world')\n  &#125;\n\n结果如下：\nb模块加载\na模块加载\nmain.js开始执行\nmain.js执行完毕\n\nmain.js 和 a.js 都引用了 b.js 模块，但是 b 模块也只加载了一次。\n3 导出绑定不能修改import导入的属性\n/************ a.js文件 ************/\nexport let num = 1\nexport const addNumber = ()=>&#123;\n    num++\n&#125;\n\n/************ main.js文件 ************/\nimport &#123;  num , addNumber &#125; from './a'\nnum = 2 //报错！！！！！！！\n\n如果直接修改，那么会报错。\nCommonjs 和 EsModule 总结Commonjs 的特性如下：\n\nCommonJS 模块由 JS 运行时实现。\nCommonJs 是单个值导出，本质上导出的就是 exports 属性。\nCommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。\nCommonJS 模块同步加载并执行模块文件。\n\nEs module 的特性如下：\n\nES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。\nES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。\nES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。\nES6 模块提前加载并执行模块文件，\nES6 Module 导入模块在严格模式下。\nES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。\n\n","slug":"commonJs与ESModule的区别","date":"2023-03-25T09:28:56.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"3d2ffd4a2e7a0c4e75c1224831f86d5a","title":"NVS的常用指令","content":"查看当前使用的nvs版本\nnvs –version或者\nnvs -v\n\n列出所有可用的nvs版本可供下载\nnvs ls-remote本地已下载\nnvs ls\n\n下载指定版本，如 nvs add 16、nvs add 16.14、nvs add lts\nnvs add \n\n删除指定版本，如 nvs rm 16、nvs rm 16.14、nvs rm lts\nnvs rm \n\n切换到指定版本，如 nvs use 16、nvs use 16.14、nvs use lts仅在此次终端会话有效，下次终端会话重新使用默认版本\nnvs use \n\n指定默认的版本，如 nvs link 16\nnvs link 这样就可以使用 nvs use 默认版本\nnvs use default或直接运行\nnvs use\n\n查看当前使用的node版本\nnvs which\n\n","slug":"NVS的常用指令","date":"2022-11-04T06:45:23.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"7792391404509b46b9c8e9c39373506c","title":"DOM与虚拟DOM","content":"DOM是什么？官方是这么说的：文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将 web 页面和脚本或程序语言连接起来。\n一个 web 页面是一个文档。这个文档可以在浏览器窗口或作为 HTML 源码显示出来。但上述两个情况中都是同一份文档。文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。 DOM 是 web 页面的完全的面向对象表述，它能够使用如 JavaScript 等脚本语言进行修改。\n我是这么理解的：DOM是由浏览器提供，用于映射HTML，为什么是映射呢，因为HTML改变后，浏览器页面也会发生改变，之所以页面会改变（重绘或重排），是因为DOM树发生了改变。相反，我们直接修改DOM，HTML也会跟着变。\n虚拟 DOM虚拟DOM概念随着react的诞生而诞生，由facebook提出，其卓越的性能很快得到广大开发者的认可；继react之后vue2.0也在其核心引入了虚拟DOM的概念\n什么是虚拟DOM(VDOM)？vdom可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。dom 树对应的虚拟 dom 对象（ js 对象），如下：可见上面的DOM结构，不论是标签名称还是标签的属性或标签的子集，都会对应在下面的树结构里。\nvNode在Vue.js 中虚拟 DOM 的 JavaScript 对象就是 VNode。\n为什么要使用虚拟DOM？虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在react，vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改 就变成了 js 对象的属性的更改 ，这样一来就能查找 js 对象的属性变化要比查询 dom 树的 性能开销小。\n其实并不是查询 dom 树性能开销大而是 dom 树的实现模块和 js 模块是分开的这些跨模块的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。\n他们的思想是每次更新 dom 都尽量避免刷新整个页面，而是有针对性的 去刷新那被更改的一部分 ，来释放掉被无效渲染占用的 gpu，cup 性能。\nDOM与虚拟DOM的区别\n虚拟dom不会进行重绘和回流，而真实dom会频繁重排与重绘\n虚拟dom的总损耗是“虚拟dom的增删改+真实dom的差异增删改+重排”真实dom的消耗是“真实dom全部增删改+重排”\n\n优缺点1.真实dom优点：\n\n直接操作HTML，易用\n\n缺点：\n\n解析速度慢，效率低，内存占用量高\n性能差：频繁操作真实DOM，导致重绘、回流\n\n2.虚拟dom​优点：\n\n减少真实dom的频繁更新，减少重绘回流、占用内存少\n跨平台：一套react代码可以多端运行\n\n​缺点：\n\n页面首次渲染时，由于多一层虚拟dom的计算，速度比正常慢些\n\n虚拟dom的原理diff算法 深度优先遍历，diff的过程就是调用patch函数，就像打补丁一样修改真实dom\nsnabbdomsnabbdom 是一个虚拟 DOM 库，github仓库: snabbdom.vue的虚拟DOM就是参考的snabbdom\n我们以sanbbdom为例，来看看虚拟DOM的原理下面是 官网的案例：\nimport &#123;\n  init,\n  classModule,\n  propsModule,\n  styleModule,\n  eventListenersModule,\n  h,\n&#125; from \"snabbdom\";\n\nconst patch = init([\n  // 通过传入模块初始化 patch 函数\n  classModule, // 开启 classes 功能\n  propsModule, // 支持传入 props\n  styleModule, // 支持内联样式同时支持动画\n  eventListenersModule, // 添加事件监听\n]);\n\nconst container = document.getElementById(\"container\");\n\nconst vnode = h(\"div#container.two.classes\", &#123; on: &#123; click: someFn &#125; &#125;, [\n  h(\"span\", &#123; style: &#123; fontWeight: \"bold\" &#125; &#125;, \"This is bold\"),\n  \" and this is just normal text\",\n  h(\"a\", &#123; props: &#123; href: \"/foo\" &#125; &#125;, \"I'll take you places!\"),\n]);\n// 传入一个空的元素节点 - 将产生副作用（修改该节点）\npatch(container, vnode);\n\nconst newVnode = h(\n  \"div#container.two.classes\",\n  &#123; on: &#123; click: anotherEventHandler &#125; &#125;,\n  [\n    h(\n      \"span\",\n      &#123; style: &#123; fontWeight: \"normal\", fontStyle: \"italic\" &#125; &#125;,\n      \"This is now italic type\"\n    ),\n    \" and this is still just normal text\",\n    h(\"a\", &#123; props: &#123; href: \"/bar\" &#125; &#125;, \"I'll take you places!\"),\n  ]\n);\n// 再次调用 `patch`\npatch(vnode, newVnode); // 将旧节点更新为新节点\nsnabbdom 使用 h 函数来生成 vnode ， 再通过 patch 函数去完成 DOM 的更新\n那么 patch 函数又干了些什么呢，\n进行精细比较，就是调用 patchVnode，下面看看patchVnode又干了什么\n最复杂的情况，就是调用 updateChildren 函数，具体实现，看个视频点击观看地址：https://www.bilibili.com/video/BV1Ph41117hq?share_source=copy_web&amp;vd_source=62d6832488f9b89eaf9115ceb16e9e0b\n虚拟DOM有哪些好处虚拟 DOM 不会立马进行排版与重绘操作虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部虚拟DOM主要做了什么虚拟DOM本身是什么（JS对象）为什么虚拟 DOM 的操作比 DOM 更快；总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作\n浏览器的虚拟DOM与真实DOM的区别（注意：需不需要虚拟DOM，其实与框架的DOM操作机制有关）虚拟DOM不会进行排版与重绘操作虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗真实DOM频繁排版与重绘的效率是相当低的虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）使用虚拟DOM的损耗计算：总损耗&#x3D;虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘直接使用真实DOM的损耗计算：总损耗&#x3D;真实DOM完全增删改+（可能较多的节点）排版与重绘总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作\n","slug":"虚拟DOM","date":"2022-07-28T13:57:49.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"8b4c372403610b1ffccec2e1fcd54ba5","title":"JS的一些小知识点","content":"var 、let 、const 的区别\n\n\n\nvar\nlet\nconst\n\n\n\n作用域\n函数作用域\n块级作用域\n块级作用域\n\n\n变量提升\n会变量提升，且会初始化赋值为undefined\n会变量提升,但不会初始化(存在暂时性死区)\n会变量提升,但不会初始化(存在暂时性死区)\n\n\n能否修改\n能修改\n能修改\n不能,但可以修改引用中的内容\n\n\nfunction sayHi() &#123;\n  console.log(name)//undefined\n  console.log(age)//ReferenceError\n  var name = 'Lydia'\n  let age = 21\n&#125;\nsayHi()\nJS 对象中 . 与 [] 的区别在javaScript中，访问对象的属性有 .property 和 [property] 两种方法\n\n相同点: 都是用来获取obj的属性值\n不同点: 静态与动态使用\n\n[ ] 运算符可以使用字符串变量的内容作为属性名，. 运算符则不能\nlet obj = &#123;\n            name1:'winnie',\n            name2:'a莹',\n            name3:'圆'\n        &#125;\n        let name = 'name3'\nconsole.log(obj.name); //当.属性 为变量时 结果为 undefined\nconsole.log(obj[name]);  //[] 变量亦能使用  结果为 圆\n[ ] 运算符可以使用纯数字作为属性名，. 运算符则不能\nlet obj = &#123;\n            name1:'winnie',\n            2:'a莹',\n            3:'圆'\n        &#125;\nconsole.log(obj[2]); // a莹\nconsole.log(obj.2);  //报错Uncaught SyntaxError: missing ) after argument list   【少了括号？？】\n事件传播的三个阶段Capturing &gt; Target &gt; Bubbling在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。\n默认情况下，事件的发生是在 冒泡阶段\n\njs隐式转换普通类型转换字符串拼接 &gt; 数字运算\n\n出现字符串拼接的情况，其他类型都要转换为字符串\n没有字符串拼接，有运算符，则全部转为数字\n\nconsole.log('1' - 2 + false);// 12false\nconsole.log(2+true);// 3\nconsole.log(-true);// -1\n\n复杂类型转换复杂数据类型在隐式转换时会先 valueOf() 取原始值，再转成 String ，然后再转成 Number 。如果转成字符串后能拼接，则不转Number，直接拼接。\nconsole.log([]+1);// '1'\nconsole.log(&#123;&#125;+1);// '[object Object]1'\nconsole.log([]-1);//-1\nconsole.log(&#123;&#125;-1);// NaN\n\n关系运算符关系运算符会把其他数据类型转换成number之后再比较关系\nconsole.log(Number('2'))//2\nconsole.log(Number('a'))//NaN\nconsole.log(Number(&#123;&#125;));//NaN\nconsole.log(Number([]));//0\nconsole.log(Number(undefined));//NaN\nconsole.log(Number(null));//0\n//例如:\nconsole.log('2'>10);//false\nconsole.log([]>-1);//true\n\nconsole.log(Boolean([]));//true\nconsole.log(Number([]));//0\nconsole.log([]==false);//true\nconsole.log(![]==false);//true 先进行布尔运算\nconsole.log(![]==0)//true\nconsole.log([]==0)//true\nconsole.log([]==[]);//false\n\n有关于字符串的比较\n\n单个字符串比较unicode编码 (始终遵循A&lt;Z&lt;a&lt;z)\n多个字符串比较从左往右依次单个比较（这里注意不会比完有一个不一样就比出结果了）\n\nconsole.log('a' > 'b');//false\nconsole.log('a' > 'A');//true\nconsole.log('abc' > 'b');//false\nconsole.log('abc' > 'aad');//tru\n\n\n\n\n\n\n特殊\nconsole.log(null == undefined);//true\n据说是因为设计者觉得它俩很像，所以才让它们相等\n\n一个有趣的题目\n//经典面试题\nvar a = ? ? ? ;\n \nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log('yes')\n&#125;\n//给a设置内容  让他实现值同时等于1 2 3\n//答案\nvar a = &#123;\n    i:0,//声明一个属性i\n    //每次对比都会先调用 valueOf() 这个方法，所以我们自己给他定义一个valueOf()\n    valueOf:function()&#123;\n        return ++this.i;//每调用一次，让对象的a属性的i值自增并返回\n    &#125;\n&#125; ;","slug":"JS的一些小知识点","date":"2022-05-20T08:20:55.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"03aba69ba9901887c6cdf14c73c6fada","title":"js类基础","content":"声明类的语法//函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //定义方法,在原型上面定义\n    Stu.prototype.getName = function () &#123;\n      console.log(this.name);\n    &#125;;\n    stu = new Stu(\"HHHH\", 19);\n    stu.getName();\n// 语法糖\n    class User &#123;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n      //定义方法\n      show() &#123;&#125; //不用加逗号\n      getName() &#123;\n        console.log(this.name);\n      &#125;\n    &#125;\n    let user = new User(\"HLT\", 21);\n    user.getName();\n\n\n\n\n\n\n注意\n用class创建的类中的方法是不能遍历的\n//打印 User 中的 getName 的描述\nconsole.log(\n      JSON.stringify(\n        Object.getOwnPropertyDescriptor(User.prototype, \"getName\"),\n        null,\n        2\n      )\n    );\n    //结果\n    /*&#123;\n      \"writable\": true,\n      \"enumerable\": false,//不可枚举\n      \"configurable\": true\n    &#125;*/\n    //遍历 User 的实例\n    for (const key in user) &#123;\n      console.log(key); //name age\n    &#125;\n但用构造函数创建的类中的方法可以遍历\n//打印 Stu 中的 getName 的描述\nconsole.log(\n      JSON.stringify(\n        Object.getOwnPropertyDescriptor(Stu.prototype, \"getName\"),\n        null,\n        2\n      )\n    );\n    //结果\n    /*&#123;\n      \"writable\": true,\n      \"enumerable\": true,//可枚举\n      \"configurable\": true\n    &#125;*/\n    //遍历 Stu 的实例\n    for (const key in stu) &#123;\n      console.log(key);//name age getName\n    &#125;\n\n\n类的静态属性静态属性：实例对象无法访问，只能通过构造函数名来访问\n //函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //静态属性 直接在构造函数上添加\n    Stu.age = 12;\n    let s = new Stu(\"HLT\", 22);\n    console.log(s.age);\n    console.log(Stu.age);\n//语法糖写法\n    class User &#123;\n      //静态属性 要加 static 关键字\n      static age = 33;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n    &#125;\n    let u = new User(\"HHHH\", 22);\n    console.log(u.age);\n    console.log(User.age);\n静态方法静态方法：实例对象无法访问，只能通过构造函数名来访问\n //函数写法\n    function Stu(name, age) &#123;\n      this.name = name;\n      this.age = age;\n    &#125;\n    //静态方法 直接在构造函数上添加, this 指向构造函数\n    //这是一个创建实例的方法\n    Stu.create = function (...args) &#123;\n      return new this(...args);\n    &#125;;\n    let s = Stu.create(\"HLT\", 22);\n    console.log(s);\n//语法糖写法\n    class User &#123;\n      //静态方法 要加 static 关键字 this指向此类\n      //这是一个创建实例的方法\n      static create(...args) &#123;\n        return new this(...args);\n      &#125;\n      constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n      &#125;\n    &#125;\n    let u = User.create(\"HHHH\", 22);\n    console.log(u);\n静态方法的练习const data = [\n  &#123; name: \"mysql\", price: 212 &#125;,\n  &#123; name: \"js\", price: 502 &#125;,\n  &#123; name: \"vue\", price: 21 &#125;,\n];\nclass Lesson &#123;\n  constructor(data) &#123;\n    this.model = data;\n  &#125;\n  //将每个数据创建为实例对象\n  static create(data) &#123;\n    return data.map((item) => new this(item));\n  &#125;\n  //获取最高的价格\n  static maxPrice(data) &#123;\n    return data.sort((a, b) => b.price() - a.price())[0];\n  &#125;\n  //获取价格\n  price() &#123;\n    return this.model.price;\n  &#125;\n  //获取名字\n  name() &#123;\n    return this.model.name;\n  &#125;\n&#125;\nlet lesson = Lesson.create(data);\nconsole.log(lesson); //为什么输出的结果是排序后的\nconsole.log(Lesson.maxPrice(lesson).name());","slug":"js类基础","date":"2022-05-19T02:16:01.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"d64bde8be5157d28cbe41e0c0eca479d","title":"Vue知识点","content":"生命周期生命周期图: \nkeep-liveprops\ninclude - string | RegExp | Array。只有名称匹配的组件会被缓存。\nexclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存。\nmax - number | string。最多可以缓存多少组件实例。\n\n用法&lt; keep-alive &gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt; transition &gt; 相似， &lt; keep-alive &gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n当组件在 &lt; keep-alive &gt; 内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用，取而代之的是 activated 和 deactivated。(这会运用在 &lt; keep-alive &gt; 的直接子节点及其所有子孙节点。)\n主要用于保留组件状态或避免重新渲染。\n&lt;!-- 基本 -->\n&lt;keep-alive>\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- 多个条件判断的子组件 -->\n&lt;keep-alive>\n  &lt;comp-a v-if=\"a > 1\">&lt;/comp-a>\n  &lt;comp-b v-else>&lt;/comp-b>\n&lt;/keep-alive>\n\n&lt;!-- 和 `&lt;transition>` 一起使用 -->\n&lt;transition>\n  &lt;keep-alive>\n    &lt;component :is=\"view\">&lt;/component>\n  &lt;/keep-alive>\n&lt;/transition>\n\n注意， &lt; keep-alive &gt; 是用在其一个直属的子组件被切换的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素， 要求同时只有一个子元素被渲染。\ninclude 和 excludeinclude 和 exclude prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：\n&lt;!-- 逗号分隔字符串 -->\n&lt;keep-alive include=\"a,b\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- regex (使用 `v-bind`) -->\n&lt;keep-alive :include=\"/a|b/\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n&lt;!-- Array (使用 `v-bind`) -->\n&lt;keep-alive :include=\"['a', 'b']\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。\nmax最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n&lt;keep-alive :max=\"10\">\n  &lt;component :is=\"view\">&lt;/component>\n&lt;/keep-alive>\n\n\n\n\n\n\n警告\n&lt; keep-alive &gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。\n\nv-if   VS   v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\nv-if 与 v-show 的优先级问题\n2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。\n3.x 版本中 v-if 总是优先于 v-for 生效\n\n\n\n\n\n\n\n注意\n不推荐同时使用 v-if 和 v-for\n\nrefref 被用来给元素或子组件注册引用信息。引用信息将会被注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是那个 DOM 元素；如果用在子组件上，引用就指向组件实例：\n&lt;p ref=\"p\">hello&lt;/p>\n\n&lt;!-- vm.$refs.child 会是子组件实例 -->\n&lt;child-component ref=\"child\">&lt;/child-component>\n\n&lt;!-- 当动态绑定时，我们可以将 ref 定义为回调函数，显式地传递元素或组件实例 -->\n&lt;child-component :ref=\"(el) => child = el\">&lt;/child-component>\n关于 ref 注册时机的重要说明：因为 ref 本身是作为渲染函数的结果而创建的，在初始渲染时你不能访问它们——它们还不存在！$refs 也是非响应式的，因此你不应该试图用它在模板中做数据绑定。\nnextTick将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它。\nimport &#123; createApp, nextTick &#125; from 'vue'\n//例一\nconst app = createApp(&#123;\n  setup() &#123;\n    const message = ref('Hello!')\n    const changeMessage = async newMessage => &#123;\n      message.value = newMessage\n      await nextTick()\n      console.log('Now DOM is updated',message)\n    &#125;\n  &#125;\n&#125;)\n//例二\nconst app = createApp(&#123;\n\t  setup() &#123;\n\t    const message = ref('Hello!')\n\t    const changeMessage = async newMessage => &#123;\n\t\t\tnextTick(()=>&#123;\n\t\t\t\tconsole.log('Now DOM is updated',message)\n\t\t\t&#125;)\n\t    &#125;\n\t  &#125;\n\t&#125;)\nscoped什么是scoped在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。\nscoped的实现原理Vue中的scoped属性的效果主要是通过PostCss实现的。以下是转译前的代码:\n&lt;style scoped>\n    .example&#123;\n        color:red;\n    &#125;\n&lt;/style>\n&lt;template>\n    &lt;div>scoped测试案例&lt;/div>\n&lt;/template>\n转译后:\n.example[data-v-5558831a] &#123;\n  color: red;\n&#125;\n&lt;template>\n    &lt;div class=\"example\" data-v-5558831a>scoped测试案例&lt;/div>\n&lt;/template>\nPostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\nscoped的渲染规则\n给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素\n在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式\n\nsass 和 less 的样式穿透在Vue项目中，当我们引入第三方组件库时(如使用element-ui)，需要在局部组件中修改第三方组件库样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped\n这俩个常用的样式穿透的方式 有俩种 分别是 &#x2F;deep&#x2F; 与 ::v-deep\n外层容器 /deep/ 组件 &#123; &#125;\n\n外层容器 ::v-deep 组件 &#123; &#125;\nVue 是怎么实现响应式的//更新视图\nconst updateView = ()=>&#123;\n    console.log(\"视图更新\");\n&#125;\n\n//监视数组变化\n/**\n *  因为 Object.defineProperty 无法监视数组的变化\n *  所以重新定义数组原型\n */\nconst oldArrayProperty = Array.prototype\n\n//创建对象，原型指向 oldArrayProperty ，再扩展的新方法不会污染原型\nconst arrProto = Object.create(oldArrayProperty);\n['push','shift','unshift','pop','splice'].forEach(methodName => &#123;\n    //这个方法主要用来更新视图\n    arrProto[methodName] = function()&#123;\n        console.log(`监听到数组调用了$&#123;methodName&#125;方法`);\n        updateView()\n        //调用原来原型对象上的相应方法\n        oldArrayProperty[methodName].call(this,...arguments)\n    &#125;\n&#125;);\n\n//监听\nconst defineReactive = (data,key,value)=>&#123;\n   observe(value)   //再次判断data中每个属性是否为需要深度监视，（递归）\n   Object.defineProperty(data,key,&#123;        \n        get()&#123;\n            return value\n        &#125;,\n        set(nweValue)&#123;\n            if(nweValue !== value)&#123;\n                observe(nweValue)   //在赋值的时候判断值是否需要深度监视\n                console.log('修改  '+ key+' : '+value+'  >>>',nweValue);\n                value = nweValue\n                updateView()\n            &#125;\n        &#125;\n   &#125;)\n&#125;\n\nconst observe = (data)=>&#123;\n    if(typeof data !== 'object' || data === null)&#123;\n        return data\n    &#125;\n    if(Array.isArray(data))&#123;\n       data.__proto__ =  arrProto\n    &#125;\n     for(key in data)&#123;\n         defineReactive(data,key,data[key])\n     &#125;\n&#125;\n\nconst data = &#123;\n    aa:11,\n    bb:'123',\n    cc:&#123;\n        dd:222\n    &#125;,\n    gg:[2,2,2]\n&#125;\n\nobserve(data)\n\ndata.aa = 22\ndata.bb = 'sss'\ndata.cc.dd = 111\ndata.bb = &#123;\n    ee:'111'\n&#125;\ndata.bb.ee = 222\ndata.gg.push(222)\n","slug":"Vue知识点","date":"2022-05-18T11:02:15.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"01dafa857bbdf984f605b3b52dec3c19","title":"generator基础","content":"Generator 基础入门所谓 Generator 函数它是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即拥有暂停函数执行的效果）。\nfunction* gen() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next(); // &#123; value: 2, done: false &#125;\ng.next(); // &#123; value: 3, done: false &#125;\ng.next(); // &#123; value: undefined, done: true &#125;\ng.next(); // &#123; value: undefined, done: true &#125;\n上述的函数就是一个 Generator 生成器函数的例子，我们通过在函数声明后添加一个 * 的语法创建一个名为 gen 的生成器函数。\n调用创建的生成器函数会返回一个 Generator { } 生成器实例对象。\n\n所谓返回的 g 生成器对象你可以简单的将它理解成为类似这样的一个对象结构:\n&#123;\n    next: function () &#123;\n        return &#123;\n            done:Boolean, // done表示生成器函数是否执行完毕 它是一个布尔值\n            value: VALUE, // value表示生成器函数本次调用返回的值\n        &#125;\n    &#125;\n&#125;\n\n首先，我们通过 let g &#x3D; gen() 调用生成器函数创建了一个生成器对象 g ，此时 g 拥有 next 上述结构的 next 方法。\n  这一步，我们成为 g 为返回的生成器对象， gen 为生成器函数。通过调用生成器函数 gen 返回了生成器对象 g 。\n\n之后，生成器对象中的 next 方法每次调用会返回一次 { value:VALUE, done:boolean }的对象。\n  每次调用生成器对象的 next 方法会返回一个上述类型的 object:\n\n\n其中 done 表示生成器函数是否执行完毕,而 value 表示生成器函数中本次 yield 对应的值。\n我们来详细拆开上述函数的执行过程来看看：\n\n首先调用 gen() 生成器函数返回 g 生成器对象。\n其次返回的 g 生成器对象中拥有一个 next 的方法。\n每当我们调用 g.next() 方法时，生成器函数紧跟着上一次进行执行，直到函数碰到 yield 关键值。\nyield 关键字会停止函数执行并将 yield 后的值返回作为本次调用 next 函数的 value 进行返回。\n同时，如果本次调用 g.next() 导致生成器函数执行完毕，那么此时 done 会变成 true 表示该函数执行完毕，反之则为 false 。\n\n\n\n比如当我们调用 let g &#x3D; gen() 时，会返回一个生成器函数，它拥有一个 next方法。\n之后当第一次调用 g.next() 方法时，会执行生成器函数 gen 。函数会进行执行，直到碰到 yield 关键字会进行暂停，此时函数会暂停到 yield 1 语句执行完毕，将 1 赋给 value\n同时因为生成器函数 gen 并没有执行完毕，所以此时 done 应该为 false 。所以此时首次调用 g.next() 函数返回的应该是 { value: 1, done: false }。\n之后，我们第二次调用 g.next() 方法时，函数会从上一次的中断结果后进行执行。也就是会继续 yield 2 语句。\n当遇到 yield 2 时，又因为碰到了 yield 语句。此时函数又会被中断，因为此时函数并没有执行完成，并且yield 语句后紧挨着的是 2 所以第二个 g.next() 会返回 { value: 2 , done: false }。\n同样，yield 3; 回和前两次执行逻辑相同。\n需要额外注意的是，当我们第四次调用迭代器 g.next() 时，因为第三次 g.next() 结束时生成器函数已经执行完毕了。所以再次调用 g.next() 时，由于函数结束 done 会变为 false 。同时因为函数不存在返回值，所以 value 为 undefined。\n上边是一个基于 Generator 函数的简单执行过程，其实它的本质非常简单：\n调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 { value: Value, done: boolean }的对象。\nGenerator 函数返回值我们先来看这样一段代码：\nfunction* gen() &#123;\n  const a = yield 1;\n  console.log(a,'this is a')\n  const b = yield 2;\n  console.log(b,'this is b')\n  const c = yield 3;\n  console.log(c,'this is c')\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next('param-a'); // &#123; value: 2, done: false &#125;\ng.next('param-b'); // &#123; value: 3, done: false &#125;\ng.next('param-c'); // &#123; value: undefined, done: true &#125;\n\n// 控制台会打印:\n// param-a this is a\n// param-b this is b\n// param-c this is c\n这里，我们着重来看看调用生成器对象的 next 方法传入参数时究竟会发生什么事情，理解 next() 方法的参数是后续 Generator 解决异步的重点实现思路。\n上文我们提到过，生成器函数中的 yield 关键字会暂停函数的运行，简单来说比如我们第一次调用 g.next() 方法时函数会执行到 yield 1 语句，此时函数会被暂停。\n当第二次调用 g.next() 方法时，生成器函数会继续从上一次暂停的语句开始执行。这里有一个需要注意的点：当生成器函数恢复执行时，因为上一次执行到 const a &#x3D; yield 1 语句的右半段并没有给 const a进行赋值。\n那么此时的赋值语句 const a &#x3D; yield 1，a 会被赋为什么值呢？ 细心的同学可能已经发现了。我们在 g.next(‘param-a’) 传入的参数 param-a 会作为生成器函数重新执行时，上一次 yield 语句的返回值进行执行。\n简单来说，也就是调用 g.next(‘param-a’)恢复函数执行时，相当于将生成器函数中的 const a &#x3D; yield 1; 变成 const a &#x3D; ‘param-a’; 进行执行。\n这样，第二次调用 g.next(‘param-a’)时自然就打印出了 param-a this is a 。\n同样当我们第三次调用 g.next(‘param-b’) 时，本次调用 next 函数传入的参数会被当作 yield 2 运算结果赋值给 b 变量，执行到打印时会输出 param-b this is b。\n同理 g.next(‘paramc’) 会输出 param-c this is b。\n总而言之，当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。\n自然，第一次调用 g.next() 传入参数是毫无意义的。因为首次调用 next 函数时，生成器函数并没有任何执行自然也没有 yield 关键字处理。\n接下来我们来看看所谓的生成器函数返回值:\nfunction* gen() &#123;\n  const a = yield 1;\n  console.log(a, 'this is a');\n  const b = yield 2;\n  console.log(b, 'this is b');\n  const c = yield 3;\n  console.log(c, 'this is c');\n  return 'resultValue'\n&#125;\n\nlet g = gen();\n\ng.next(); // &#123; value: 1, done: false &#125;\ng.next('param-a'); // &#123; value: 2, done: false &#125;\ng.next('param-b') // &#123; value: 3, done: false &#125;\ng.next() // &#123; value: 'resultValue', done: true &#125;\ng.next() // &#123; value: undefined, done: true &#125;\n当生成器函数存在 return 返回值时，我们会在第四次调用 g.next() 函数恢复执行，此时生成器函数继续执行函数执行完毕。\n此时自然 done 会变为 true 表示生成器函数已经执行完毕，之后，由于函数存在返回值所以随之本次的 value 会变为 ‘resultValue’ 。\n也就是当生成器函数执行完毕时，原本本次调用 next 方法返回的 {done:true,value:undefined} 变为了{ done:true,value:’resultValue’}。\n","slug":"generator基础","date":"2022-05-17T02:44:43.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"98c0136b7cbfc99c12e56d7a4696a8e1","title":"async、await的用法","content":"async await 的用法描述async函数可能包含0个或者多个await表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用async &#x2F; await关键字就可以在异步代码中使用普通的try &#x2F; catch代码块。async函数一定会返回一个promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。\n\n\n\n\n\n\n备注\nawait关键字只在async函数内有效。如果你在async函数体之外使用它，就会抛出语法错误 SyntaxError 。\n\n\n\n\n\n\n\n备注\nasync&#x2F;await的目的为了简化使用基于promise的API时所需的语法。async&#x2F;await的行为就好像搭配使用了生成器和promise。\n\n返回值一个Promise，这个promise要么会通过一个由async函数返回的值被解决，要么会通过一个从async函数中抛出的（或其中没有被捕获到的）异常被拒绝。\n例子//成功的promise\n    function testResolve(val) &#123;\n      return new Promise((resolve) => &#123;\n        setTimeout(() => &#123;\n          resolve(val);\n        &#125;, 1000);\n      &#125;);\n    &#125;\n    //失败的promise\n    function testReject(val) &#123;\n      return new Promise((resolve, reject) => &#123;\n        setTimeout(() => &#123;\n          reject(val);\n        &#125;, 1000);\n      &#125;);\n    &#125;\n    // 加了async 的方法会返回一个promise（默认undefined)\n    async function get() &#123;\n      //使用 try/catch 抛出错误\n      try &#123;\n        //await后的代码会等待promise完成后才执行\n        let res1 = await testResolve(111);\n        console.log(res1);//111\n        let res2 = await testReject(222);\n        console.log(res2);\n        let res3 = await testResolve(333);\n        console.log(res3);\n      &#125; catch &#123;\n        return \"失败\";\n      &#125;\n      return \"成功\";\n    &#125;\n    get()\n      .then((res) => console.log(res))\n      .catch((res) => console.log(res));//失败\n提示async function foo() &#123;\n   return 1\n&#125;\n// 等价于:\nfunction foo() &#123;\n   return Promise.resolve(1)\n&#125;\nasync函数的函数体可以被看作是由0个或者多个await表达式分割开来的。从第一行代码直到（并包括）第一个await表达式（如果有的话）都是同步运行的。这样的话，一个不含await表达式的async函数是会同步运行的。然而，如果函数体内有一个await表达式，async函数就一定会异步执行。\n例如：\nasync function foo() &#123;\n   await 1\n&#125;\n// 等价于:\nfunction foo() &#123;\n   return Promise.resolve(1).then(() => undefined)\n&#125;","slug":"async、await的用法","date":"2022-05-11T13:34:32.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"aa391de26147a897ddf914bd7b14edb4","title":"JS相关功能的实现","content":"JS相关功能的实现节流let dom1 = document.querySelector(\"#dom1\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\n//第一个参数为 点击事件的操作函数 第二个参数为 延迟操作的时间\nfunction throttle(fn, delay) &#123;\n//定义一个定时器变量  用于判断点击时是否有定时器\nlet timer = null;\n//返回一个函数，每次点击 就会调用这个函数，所以函数的 this 是 dom1\nreturn function () &#123;\n    //有定时器就直接返回\n    if (timer) return;\n    //没有定时器就创建一个\n    timer = setTimeout(() => &#123;\n    //调用点击事件的操作，绑定到dom1上，arguments是点击事件\n    fn.apply(this, arguments);\n    // 清除定时器\n    timer = null;\n    &#125;, delay);\n&#125;;\n&#125;\ndom1.addEventListener(\"click\", throttle(point, 1000));\n防抖let dom2 = document.querySelector(\"#dom2\");\n//点击事件的操作\nfunction point(e) &#123;\nconsole.log(this, e.offsetX, e.offsetY);\n&#125;\nlet dom2 = document.querySelector(\"#dom2\");\nfunction debounce(fn, delay) &#123;\nlet timer = null;\nreturn function () &#123;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => &#123;\n    fn.apply(this, arguments);\n    &#125;, delay);\n&#125;;\n&#125;\ndom2.addEventListener(\"click\", debounce(point, 1000));\nnewfunction myNew(fun,...arg)&#123;\n   // 创建一个对象\n   let instance = &#123;&#125;\n   // 对象的__proto__指向构造函数的prototype\n   instance.__proto__ = fun.prototype\n   // 改变构造函数的this指向，并传递参数\n   let person =  fun.call(instance,...arg)\n   //如果构造函数中手动返回一个对象，这个myNew将返回构造函数中的对象(我也不知道为什么要这样)\n   return typeof person===\"object\"? person:instance\n &#125;\n function Person(name) &#123;\n   this.name = name\n   // return &#123;a:'a'&#125;\n &#125;\n Person.prototype.sayName = function() &#123;\n   console.log(`My name is $&#123;this.name&#125;`)\n &#125;\n const me = myNew(Person, '小灵通')\n me.sayName()\n console.log(me)\ncallcall方法的四个步骤:\n\n将 被调用的方法(print) 作为 调用者(context)的属性\n在调用者上调用方法(print)\n删除之前调用的方法\n返回结果\n\n实现：\nFunction.prototype._call = function (context = window, ...args) &#123;\n  context.fn = this; //context就是调用者，将this（要调用的方法print）作为属性\n  const res = context.fn(...args); //调用context中的fn，fn中的this就指向context了\n  delete context.fn; //调用完后删除属性\n  return res; //返回调用结果\n&#125;;\n\n//测试\nlet obj1 = &#123;\n  name: \"hlt\",\n  print: function (a, b, c) &#123;\n    console.log(this.name);\n    console.log(a + b + c);\n  &#125;,\n&#125;;\n\nlet obj2 = &#123;\n  name: \"wj\",\n&#125;;\n\nobj1.print(1, 2, \"d\");//hlt 3d\n\nobj1.print._call(obj2, 2, \"d\", 2);//wj 2d2\n\napply跟call类似，就是传参方式不同，call的参数是散列的，apply的参数是一个数组\nFunction.prototype._apply = function (context, arr) &#123;\n  context.fn = this;\n  const res = context.fn(...arr);\n  delete context.fn;\n  return res;\n&#125;;\n\n//测试\nlet obj1 = &#123;\n  name: \"hlt\",\n  print: function (a, b, c) &#123;\n    console.log(this.name);\n    console.log(a + b + c);\n  &#125;,\n&#125;;\n\nlet obj2 = &#123;\n  name: \"wj\",\n&#125;;\n\nobj1.print(1, 2, \"d\");\n\nobj1.print._apply(obj2, [2, \"d\", 2]);\n\nbindbind返回一个函数，要再次调用才能得到结果我们先将被调用的函数保存起来，在返bind函数返回的函数中使用被调用的函数调用apply\nFunction.prototype._bind = function (context = window, ...args) &#123;\n  const fn = this;\n  return function () &#123;\n    fn.apply(context, args);\n  &#125;;\n&#125;;\n\n//测试\nlet obj1 = &#123;\n  name: \"hlt\",\n  print: function (a, b, c) &#123;\n    console.log(this.name);\n    console.log(a + b + c);\n  &#125;,\n&#125;;\n\nlet obj2 = &#123;\n  name: \"wj\",\n&#125;;\n\nobj1.print(1, 2, \"d\");\n\nconst res = obj1.print._bind(obj2, 2, \"d\", 2);\nres();","slug":"JS相关功能的实现","date":"2022-04-27T06:03:21.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"9f4d3521f710364c385149f2cdd3363c","title":"promise的基本用法","content":"promise 是干什么的promise是异步编程的一种解决方案\npromise的状态promise有三种状态\n\npending（进行中）\nfulfilled（已成功）\nrejected（已失败）\n\n状态一旦确定，就无法更改\n如何使用promisePromise对象是一个构造函数，用来生成Promise实例\nnew promise((resolve,reject)=>&#123;\n   \t//操作\n   &#125;)\n这样你就有了一个promise实例，promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject(这两个参数也是函数)\n\nresolve()函数的作用是将promise的状态从“未完成”变为“成功”\nreject()函数的作用是将promise的状态从“未完成”变为“失败”\n\n每当promise的状态改变，都会调用then()\nthen( )描述then()方法用于指定当前实例状态发生改变时的回调函数。它返回一个新的Promise实例。\n语法Promise.prototype.then(onFulfilled, onRejected);\n参数\n\n\n参数\n描述\n\n\n\nonFulfilled\n当前实例变成fulfilled状态时，该参数作为回调函数被调用。\n\n\nonRejected\n当前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n\n\n\n\n\n\n\n注意\nonFulfilled将接收一个参数，参数值由当前Promise实例内部的resolve()方法传值决定；onRejected将接收一个参数，参数值由当前Promise实例内部的reject()方法传值决定。\n\n例1： test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\") 或者 reject(\"失败\")\n &#125;)\n test1.then(\n //接受成功状态的回调\n \t(res)=>&#123;\n    \t\tconsole.log(res)//成功\n     &#125;,\n //接受失败状态的回调\n     (err)=>&#123;\n \t\t\t console.log(err)//失败\n \t&#125;\n )\n例2：由于在每个then中传入对失败状态进行处理的回调函数过于繁琐。这个例子中在最后对peomise的失败状态进行处理，前面每个then中没有传入对失败状态进行处理的回调函数，所以前面的then遇到错误会直接返回错误，不进行处理，知道遇到能处理的错误的then\n test1 = new promise((resolve,reject)=>&#123;\n  \t...\n//经过一些列操作后将改变状态\n    resolve(\"成功\")\n &#125;)\n  test1\n      .then((res) => &#123;\n        console.log(res);//成功\n        return new Promise((resolve, reject) => &#123;\n          resolve(\"内层promise成功\");\n        &#125;).then((res) => &#123;\n          console.log(res);//内层promise成功\n          return 1234;\n        &#125;);\n      &#125;)\n      .then((res) => console.log(res))//1234\n      //处理错误信息\n      .then(undefined,(res)=>&#123;\n         console.log(res)\n      &#125;)\ncatch( )描述catch() 方法返回一个Promise()，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。 (事实上, calling obj.catch(onRejected) 内部calls obj.then(undefined, onRejected)).说白了就是Promise.prototype.then(undefined, onRejected)的语法糖\n语法promise.prototype.catch(onRejected)\n参数\n\n\n参数\n描述\n\n\n\nonRejected\n前实例变成reject状态时，该参数作为回调函数被调用。\n\n\n返回值默认返回一个新的promise实例\nreturn Promise.resolve(undefined);\n例3new promise((resolve,reject)=>&#123;\n   reject('失败')\n&#125;)\n.then(res=>console.log(res))//不会执行\n.catch(res=>console.log(res))//失败\nPromise.all()描述  Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息\n用法 const promise0 = [1, 2, 3].map((val) => &#123;\n  return new Promise((resolve, reject) => &#123;\n    setTimeout(() => &#123;\n      resolve(++val);\n    &#125;, 1000);\n  &#125;);\n&#125;);\nconst promise1 = new Promise((resolve, reject) => &#123;\n  reject(\"错误\");\n&#125;);\nPromise.all([...promise0, promise1])\n  .then((res) => console.log(res))\n  .catch((res) => console.log(res));\nPromise.race( )描述   race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。如果传的迭代是空的，则返回的 promise 将永远等待。如果迭代包含一个或多个非承诺值和&#x2F;或已解决&#x2F;拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。\n用法  let promise1 = new Promise((resolve, reject) => &#123;\n  setTimeout(() => &#123;\n    resolve(\"promise1 OK\");\n  &#125;, 1000);\n&#125;);\nlet promise2 = new Promise((resolve, reject) => &#123;\n  setTimeout(() => &#123;\n    resolve(\"promise2 OK\");\n  &#125;, 5000);\n&#125;);\nPromise.race([promise1, promise2])\n  .then((val) => &#123;\n    console.log(val);\n  &#125;)\n  .catch((err) => &#123;\n    console.log(err);\n  &#125;);\n  //封装\nfunction request(url, delay) &#123;\n  let promises = [\n    // 发请求\n    // axios.get(url),\n    //模拟请求，假设请求花了1秒钟\n    new Promise((resolve, reject) => &#123;\n      setTimeout(() => &#123;\n        resolve(\"请求成功\");\n      &#125;, 1000);\n    &#125;),\n    new Promise((resolve, reject) => &#123;\n      setTimeout(() => &#123;\n        reject(\"请求超时\");\n      &#125;, delay);\n    &#125;),\n  ];\n  return Promise.race(promises);\n&#125;\n//调用，两秒后请求超时\nrequest(\"url\", 2000)\n  .then((val) => &#123;\n    console.log(val);\n  &#125;)\n  .catch((err) => &#123;\n    console.log(err);\n  &#125;);","slug":"promise的基本用法","date":"2022-04-24T09:24:00.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"a43b2263eaca0865c9412baa1c8c6f53","title":"markdown 语法","content":"欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n全新的界面设计 ，将会带来全新的写作体验；\n在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；\n增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n全新的 KaTeX数学公式 语法；\n增加了支持甘特图的mermaid语法^1 功能；\n增加了 多屏幕编辑 Markdown文章功能；\n增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；\n增加了 检查列表 功能。\n\n\n功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G\n合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n如何改变文本的样式强调文本 强调文本\n加粗文本 加粗文本\n&#x3D;&#x3D;标记文本&#x3D;&#x3D;\n删除文本\n\n\n\n\n\n\n\n\n\n引用文本\nH2O is是液体。\n2^10^ 运算结果是 1024.\n插入链接与图片链接: link.\n图片: \n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &#x3D;30x30)\n居中的图片: \n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center &#x3D;30x30)\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.\n// An highlighted block\nvar foo = 'bar';\n\n生成一个适合你的列表\n项目\n项目\n项目\n\n\n\n\n\n\n项目1\n项目2\n项目3\n\n\n 计划任务\n 完成任务\n\n创建一个表格一个简单的表格是这么创建的：\n\n\n\n项目\nValue\n\n\n\n电脑\n$1600\n\n\n手机\n$12\n\n\n导管\n$1\n\n\n设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右\n\n\n\n第一列\n第二列\n第三列\n\n\n\n第一列文本居中\n第二列文本居右\n第三列文本居左\n\n\nSmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n\n\n\nTYPE\nASCII\nHTML\n\n\n\nSingle backticks\n&#39;Isn&#39;t this fun?&#39;\n‘Isn’t this fun?’\n\n\nQuotes\n&quot;Isn&#39;t this fun?&quot;\n“Isn’t this fun?”\n\n\nDashes\n-- is en-dash, --- is em-dash\n– is en-dash, — is em-dash\n\n\n创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors:  JohnLuke如何创建一个注脚一个具有注脚的文本。^2\n注释也是必不可少的Markdown将文本转换为 HTML。\n*[HTML]:   超文本标记语言\nKaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) &#x3D; (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分\n$$\\Gamma(z) &#x3D; \\int_0^\\infty t^{z-1}e^{-t}dt,.$$\n\n\n\n\n\n\n\n\n\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n新的甘特图功能，丰富你的文章gantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n\n关于 甘特图 语法，参考 这儿,\n\nUML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n\n这将产生一个流程图。:\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D&#123;菱形&#125;\nC --> D\n\n\n关于 Mermaid 语法，参考 这儿,\n\nFLowchart流程图我们依旧会支持flowchart的流程图：\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n\n\n关于 Flowchart流程图 语法，参考 这儿.\n\n导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。\n导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。\n","slug":"如何使用-hexo-写文章","date":"2022-04-23T12:12:13.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"dc4cb5cb1f0d4d2a4dece148e4835efd","title":"HTML、CSS相关问题","content":"HTMLHTML 语义化\n让人更容易读懂\n让搜索引擎更容易读懂（SEO）\n\n块级元素&amp;行内元素两者区别\n\n块级元素会独占一行，其宽度自动填满其父元素宽度\n\n行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化\n\n一般情况下，块级元素可以设置 width, height属性，行内元素设置width, height无效(注意：块级元素即使设置了宽度，仍然是独占一行的)\n块级元素可以设置margin 和 padding. 行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）\n\n还有一种特殊的元素叫做行内块元素可设置宽度和高度以及外边距和内边距的所有样式\n常见元素\n\n行内元素有：heda meat title lable span br a style em b i strong\n\n块级元素有：body from select textarea h1-h6 html table button hr p ol ul dl cnter div\n\n行内块元素常见的有： img input td\n\n\nCSS盒模型宽度计算offsetWidth的定义offsetWidth &#x3D; 内容宽度+内边距+边框，不包含外边距\nbox-sizing:border-box用于确定offsetWidth的大小使offsetWidth &#x3D; width\nmargin 纵向重叠问题纵向重叠问题体现在上下元素的margin-bottom和margin-top发生重叠。这种情况下，上下元素的间距由大的margin决定\n注意：高度为0的元素的上下margin相当于被直接忽略\n\n例子：\n&lt;body&gt;\n  &lt;p&gt;hello&lt;&#x2F;p&gt;\n  &lt;p&gt;&lt;&#x2F;p&gt;\n  &lt;p&gt;&lt;&#x2F;p&gt;\n  &lt;p&gt;&lt;&#x2F;p&gt;\n  &lt;p&gt;world&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;style&gt;\n  p &#123;\n    margin-top: 100px;\n    margin-bottom: 150px;\n  &#125;\n&lt;&#x2F;style&gt;\n如上例所示，hello与world的间距为150px\nBFCblock format context 块级格式化上下文是一块独立的渲染区域，内部元素渲染不会影响边界以外的元素\n触发BFC的条件\nfloat 不为 none\noverflow 不为 visible\nposition 为 absolute 或 fixed\ndisplay 为 flex inline-block等\n\nBFC的作用1.解决外边距的塌陷问题(垂直塌陷)\n将边距塌陷的元素放进BFC容器中\n\n2.解决包含塌陷(有时候我们给子元素加margin可能会带着父元素一起跑)\n将父元素设置BFC\n\n3.清除浮动（子元素浮动，父元素高度塌陷）\n将浮动元素的父元素设置BFC\n\n4.BFC可以阻止标准流元素被浮动元素覆盖\n将被覆盖的元素设置BFC\n\nabsolute 和 relative 定位\nrelative 依据自身原始位置进行定位\nabsolute 依据最近一层的有定位的元素进行定位（写有absolute、relative、fixed 的元素）\n\n注意： 使用absolute定位时，如果父元素或祖先元素都没有使用定位，那么将相对于body定位\n","slug":"HTML、CSS知识点","date":"2022-04-14T08:23:51.000Z","categories_index":"","tags_index":"","author_index":"HLT"},{"id":"27ab440eca5b68e7c8a1f3c654267291","title":"JavaScript 模块化","content":"一. 什么是模块化\n将一个复杂的程序，依据一定的规则（规范）封装成一个或多个块（文件）\n块的内部实现是私有的，只暴露一些接口（方法）供外部使用\n\n二. 模块化的发展过程2.1 无模块化时代在 Ajax 还未提出之前，JavaScript 只用来在网页上进行表单校验提交，渲染 DOM\n============ 某 .js 文件 ============\n\nvar str, num;\n \nfunction submit() &#123;\n  str = document.getElementById(\"xx\").value;\n  if (str) &#123; ... &#125; else &#123; ... &#125;\n    ...\n  num = 1;\n  for (var i = 0; i &lt; 10; i++) &#123; num++; ... &#125;\n&#125;\n \nform.submit();\n \n \n============ 某 .html 文件 ============\n\n&lt;script type=\"text/javascript\" src=\"a.js\">&lt;/script>\n&lt;script type=\"text/javascript\" src=\"b.js\">&lt;/script>\n&lt;script type=\"text/javascript\" src=\"main.js\">&lt;/script>\n缺点：全局变量污染、函数命名冲突、文件依赖顺序\n2.2 模块化雏形时代2006 年，Ajax 的概念被提出，前端拥有了 主动向服务端发送请求，并操作返回数据 的能力，传统网页向 “富客户端” 发展出现了简单的 “功能对象” 封装\n2.2.1 namespace 模式\n优点：减少了全局变量\n缺点：数据不安全（外部可以直接修改模块内部的数据），模块名称会暴露在全局，存在命名冲突，依赖顺序问题\n\n============ 模块 .js 文件 ============\n \nvar myModule = &#123;\n  first_name: \"www.\",\n  second_name: \"baidu.com\",\n  getFullName: function () &#123;\n    return this.first_name + this.second_name;\n  &#125;,\n&#125;;\n \n \n============ .html文件 调用 模块.js ============\n \nmyModule.first_name = \"img.\";\nconsole.log(myModule.getFullName());\n\n\n2.2.2 自执行匿名函数（闭包）模式\n优点：变量、方法全局隐藏，模块私有化\n缺点：模块名称会暴露在全局，存在命名冲突，依赖顺序问题\n\n============ 模块 .js 文件 ============\n \n(function (window) &#123;\n  let _moduleName = \"module\";\n  function setModuleName(name) &#123;\n    _moduleName = name;\n  &#125;\n  function getModuleName() &#123;\n    return _moduleName;\n  &#125;\n  window.moduleA = &#123; setModuleName, getModuleName &#125;;\n&#125;)(window);\n \n \n============ .html文件 调用 模块.js ============\n \nmoduleA.setModuleName(\"html-module\");\nconsole.log(moduleA.getModuleName());\n \nconsole.log(moduleA._moduleName); //模块不暴露，无法访问模块内属性方法\n\n2.2.3 模块化雏形时代问题总结\n如何安全的封装一个模块的代码？（不污染模块外的任何代码）\n如何唯一标识一个模块？\n如何优雅的把模块的 API 暴漏出去？（不能增加全局变量）\n如何方便的使用所依赖的模块？\n\n三. 模块化规范3.1 CommonJS2009 年 Node.js 发布，采用 CommonJS 模块规范\nCommonJS 模块规范特点：\n\n每个文件都是一个模块实例，代码运行在模块作用域，不会污染全局作用域\n文件内通过 require 对象引入指定模块，通过 exports 对象来向外暴漏 API，文件内定义的变量、函数，都是私有的，对其他文件不可见\n每个模块加载一次之后就会被 缓存\n所有文件加载均是 同步完成，加载的顺序，按照其在代码中出现的顺序\n模块输出的是一个值的拷贝，模块内部的变化不会影响该值\n\n============ 模块 .js 文件 ============\n \nlet _moduleName = \"module\";\nfunction setModuleName(name) &#123;\n  _moduleName = name;\n&#125;\nfunction getModuleName() &#123;\n  return _moduleName;\n&#125;\nmodule.exports = &#123; setModuleName, getModuleName &#125;;\n \n \n============ .html文件 调用 模块.js ============\n \n const moduleJS = require(\"模块 .js文件\")\n moduleJS.setModuleName('123')\n let moduleName = moduleJS.getModuleName()//123\n缺点：模块同步加载导致：资源消耗多，等待时间长，适用于服务器编程\n3.2 AMD &#x2F; RequireJSCommonjs 局限性：\n\n基于 Node.js 原生 API 在服务端可以实现模块 同步加载，但仅局限于服务端，客户端如果同步加载依赖的话，时间消耗非常大，于是 AMD 规范诞生了\n\n何谓 AMD？\n\nAMD 是 ”Asynchronous Module Definition” 的缩写，意思就是 ”异步模块定义”\n它采用 异步方式 加载模块，模块的加载不影响它后面语句的运行\n所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（依赖前置），这个回调函数才会运行\n\n何谓 RequireJS？\n\nRequireJS 是一个工具库，主要用于客户端的模块管理，它的模块管理遵守 AMD 规范\nRequireJS 的基本思想：通过 define 方法将代码定义为模块，通过 require 方法实现代码的模块加载\n\n举个栗子：定义两个模块，一个没有依赖，一个有依赖\n// module1.js 定义没有依赖的模块\ndefine(function () &#123;\n  let _moduleName = \"module\";\n  function getName() &#123;\n    return _moduleName;\n  &#125;\n  return &#123; getName &#125;; // 暴露模块\n&#125;);\n \n \n// module2.js 定义有依赖的模块\ndefine([\"module1\"], function (module1) &#123;\n  let _firstName = \"AMD\";\n  function getFullName() &#123;\n    return _firstName + \" \" + module1.getName();\n  &#125;\n  function setFirstName(name) &#123;\n    _firstName = name;\n  &#125;\n  // 暴露模块\n  return &#123; _firstName, getFullName, setFirstName &#125;;\n&#125;);\n\n在 main.js 中使用这两个模块\nmain.js 相当于一个工具库，对各种模块路径、基本使用方法进行封装\n\n// mian.js\nrequire.config(&#123;\n  paths: &#123;\n    module1: \"./modules/module1\",\n    module2: \"./modules/module2\",\n    // 第三方库模块\n    jquery: \"./libs/jquery.min\",\n  &#125;,\n&#125;);\n \nrequire([\"module2\", \"jquery\"], function (module2, jquery) &#123;\n  console.log(module2.getFullName());\n  module2.setFirstName(\"AMD-AMD\");\n  console.log(module2.getFullName());\n  console.log(module2._firstName);\n  jquery(\"#moduleId\").html(\"&lt;i>My name is jquery-module&lt;/i>\");\n&#125;);\n\n.html 中引入工具库，并定义 js 主文件\n\n// .html 中引入工具库，并定义js主文件\n&lt;script data-main=\"./main\" src=\"./libs/require.js\">&lt;/script>\n\nAMD &#x2F; RequireJS 特点：浏览器直接运行无需编译，异步加载，依赖关系清晰\n\n3.3 CMD &#x2F; SeaJS借鉴了 Commonjs 的规范与 AMD 规范，国内（阿里）诞生了一个 CMD（Common Module Definition）规范，CMD 规范专门用于浏览器端跟 RequireJs 类似，SeaJs 是 CMD 规范的实现CMD 是 SeaJs 推广过程中诞生的规范，CMD 借鉴了很多 AMD 和 Commonjs 优点\n与 AMD 非常类似，CMD 规范（2011）具有以下特点：\n\ndefine 定义模块，require 加载模块，exports 暴露变量\n不同于 AMD 的依赖前置，CMD 推崇依赖就近（需要的时候再加载）\n推崇 api 功能单一，一个模块干一件事\n\n// module.1\ndefine(function (require, exports, module) &#123;\n  module.exports = &#123;\n    msg: \"I am module1\",\n  &#125;;\n&#125;)\n \n// module.2\ndefine(function (require, exports, module) &#123;\n  var module2 = require(\"./module1\");\n  function show() &#123;\n    console.log(\"同步引入依赖模块1 \" + module2.msg);\n  &#125;\n  exports.showModule = show;\n&#125;);\n \n \n// main.js\ndefine(function (require) &#123;\n  var m2 = require(\"./modules/module2\");\n  m2.showModule();\n&#125;);\n \n \n// .html中引入工具库，并定义 js 主文件\n&lt;script type=\"text/javascript\" src=\"./libs/sea.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  seajs.use('./main')\n&lt;/script>\n\n3.4 AMD vs CMD\nAMD 推崇依赖前置\nCMD 推崇依赖就近\n\n// AMD\ndefine(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好\n a.doSomething()\n ...\n b.doSomething()\n ...\n&#125;)\n \n \n// CMD\ndefine(function(require, exports, module) &#123;\n var a = require('./a')\n a.doSomething()\n ...\n var b = require('./b') // 依赖可以就近书写\n b.doSomething()\n ...\n&#125;)\n\n四. ES6 与 JavaScript模块化 关系4.1 ES6 中的模块化示例2015 年，ES6 规范中，将 JavaScript模块化 纳入 JavaScript 标准ES6 中的模块化，在 CommonJS 的基础上进行改造，关键字有 import，export，default，as，from\n// 模块js\nlet _moduleName = \"module\";\nfunction setModuleName(name) &#123;\n  _moduleName = name;\n&#125;\nfunction getModuleName() &#123;\n  return _moduleName;\n&#125;\nexport &#123; setModuleName, getModuleName &#125;;\n \n \n// 调用js\nimport &#123; getModuleName, setModuleName &#125; from \"./es6.module\";\nsetModuleName(\"es6 Module\");\nconsole.log(getModuleName());\n\n4.2 CommonJS vs ES6\n模块内部值的改变 是否影响 外部引用的该模块？\n\nCommonJS 模块输出的是一个值的拷贝，原来模块中的值改变，不会影响已经加载模块中的值\nES6 模块输出的是值的只读引用，模块内值改变，引用也改变\n\n\n模块导出内容范围？\n\nCommonJS 模块是运行时加载，加载的是整个模块，所有的接口会全部加载\nES6 模块是编译时输出接口，可以单独加载其中的某个接口\n\n\n\n五. CommonJS vs AMD vs CMD vs ES6\nCommonJS 规范主要用于服务端编程，加载模块是同步的；不适合在浏览器环境，因为浏览器资源是异步加载的，存在阻塞加载，也因此有了 AMD、CMD\nAMD 规范在浏览器环境中，异步加载模块，而且可以并行加载多个模块\nCMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，代码更简单\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为 浏览器 - 和 服务器 通用的模块解决方案\n\n","slug":"JavaScript-模块化","date":"2022-01-02T12:47:58.000Z","categories_index":"","tags_index":"","author_index":"HLT"}]